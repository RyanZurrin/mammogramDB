<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>omama.data API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>omama.data</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import os
import pickle
import re
import time
import pprint
import random
from collections import Counter
import pydicom as dicom
from types import SimpleNamespace
from typing import Generator
from omama.loaders.data_loader import DataLoader


class Data:
    &#34;&#34;&#34;Singleton Data class used to represent and explore dicom data

    Attributes
    ----------
    total_2d_noncancer : int
        total number of 2D dicoms with a label of NonCancer
    total_2d_cancer : int
        total number of 2D dicoms with a label of IndexCancer
    total_2d_preindex : int
        total number of 3D dicoms with a label of PreIndexCancer
    total_3d_noncancer : int
        total number of 3D dicoms with a label of NonCancer
    total_3d_cancer : int
        total number of 3D dicoms with a label of IndexCancer
    total_3d_preindex : int
        total number of 3D dicoms with a label of PreIndexCancer
    &#34;&#34;&#34;

    dl = None  # DataLoader object
    # total number of 2D dicoms with a label of NonCancer
    total_2d_noncancer = 0
    # total number of 2D dicoms with a label of IndexCancer
    total_2d_cancer = 0
    # total number of 3D dicoms with a label of PreIndexCancer
    total_2d_preindex = 0
    # total number of 3D dicoms with a label of NonCancer
    total_3d_noncancer = 0
    # total number of 3D dicoms with a label of IndexCancer
    total_3d_cancer = 0
    # total number of 3D dicoms with a label of PreIndexCancer
    total_3d_preindex = 0
    # the sorted images from all studies. This is the list that image_id is
    # derived from
    _image_paths = []
    # the sorted study paths to all studies. This is the list study_id is
    # derived from
    _study_paths = []
    # dictionary of the label mappings
    _label_mapping_dict = {}
    # dictionary of the generated stats about the data contained in the Data
    # instance
    _stats = {}
    # dictionary of all the labels contained in the Data object instance
    _labels = {}
    # dictionary of flags used while fetching filtered data
    _filtered_flags = {}
    # dictionary of sop_uid to cancer labels
    pat_id_to_label_dict = {}

    _caselist_path = None
    _cache = None
    _load_cache = None
    _print_data = None
    instance = None

    def __new__(
        cls,
        data_loader: DataLoader,
        cache: bool = False,
        load_cache: bool = False,
        cache_paths: list = None,
        print_data: bool = False,
        timing: bool = False,
    ):
        &#34;&#34;&#34;Initializes the Data class and prepares the data for exploratory
        jupyter notebook sessions

        Parameters
        ----------
        data_loader : DataLoader
            object used to tell the Data class where to find the data
        cache : bool
            (default False) whether to cache the data
        load_cache : bool
            (default False) whether to load the data from the cache
        print_data : bool
            (default is False)
            prints out the detailed dictionary of information about all the
            studies and the combined data as well
        timing : float
            sets the timers in the initializing methods to true, and prints out
            how long each one took
            (default is False)
        &#34;&#34;&#34;
        t0 = time.time()
        # allow for multiple instances of the Singleton class as long as different
        # data_loader objects are passed in
        if cls.instance is None or cls.dl != data_loader:
            cls.destroy()
            cls.dl = data_loader
            cls.instance = super().__new__(cls)
            if cache_paths is not None:
                cls.dl.cache_paths = cache_paths
            cls._caselist_path = cls.dl.caselist_path
            cls._cache = cache
            cls._load_cache = load_cache
            cls._print_data = print_data
            print(&#34;DataLoader type is: &#34;, type(cls.dl))
            # initialize the data
            cls._init(timing=timing)
        if timing:
            cls.timing(t0, &#34;total __init__&#34;)
        if cls._print_data:
            pprint.pprint(cls._stats)

        return cls.instance

    @classmethod
    def __str__(cls):
        &#34;&#34;&#34;Prints out the class name and the number of studies and images in
        the data
        &#34;&#34;&#34;
        # save the pprint.pprint into a string
        s = pprint.pformat(cls._stats)
        return f&#34;{cls.__name__}({s})&#34;

    @classmethod
    def __len__(cls):
        &#34;&#34;&#34;Returns the length of all the dicoms in the Data object instance

        Returns
        -------
        length of the Data object instance : int
            the length of all the dicoms in the Data object instance
        &#34;&#34;&#34;
        return len(cls._image_paths)

    @classmethod
    def __getitem__(cls, index):
        &#34;&#34;&#34;Returns the dicom at the given index, or a slice of the dicoms if
        a slice is given

        Parameter
        ---------
        index : int
            the index of the dicom to return

        Returns
        -------
        dicom : dicom.dicom.DicomImage
            the dicom at the given index
        &#34;&#34;&#34;
        # if isinstance(subscript, slice):
        #     # do your handling for a slice object:
        #     print(subscript.start, subscript.stop, subscript.step)
        # else:
        #     # Do your handling for a plain index
        #     print(subscript)
        # check if the index is a slice
        # return dicom.filereader.dcmread(cls._image_paths[index])

        if isinstance(index, slice):
            return [dicom.filereader.dcmread(path) for path in cls._image_paths[index]]
        else:
            return dicom.filereader.dcmread(cls._image_paths[index])

    @classmethod
    def __iter__(cls):
        &#34;&#34;&#34;Returns an iterator for the Data object instance

        Returns
        -------
        iterator : iterator
            an iterator for the Data object instance
        &#34;&#34;&#34;
        # use the image path to read the dicom there and return pixel data
        return (
            dicom.filereader.dcmread(path, specific_tags=cls.dl.dicom_tags)
            for path in cls._image_paths
        )

    @classmethod
    def __call__(cls, *args, **kwargs):
        if cls not in cls.instance:
            cls.instance[cls] = cls(*args, **kwargs)
        return cls.instance[cls]

    @classmethod
    def __instancecheck__(cls):
        return cls.instance

    @property
    def image_paths(self):
        return self._image_paths

    @classmethod
    def destroy(cls):
        &#34;&#34;&#34;Destroys the Data object instance&#34;&#34;&#34;
        cls.instance = None
        cls.dl = None
        # reset the class variables
        cls._study_paths = []
        cls._image_paths = []
        cls._map = {}
        cls._stats = {}
        cls._cache = False
        cls._load_cache = False
        cls._print_data = False
        cls._caselist_path = None
        cls._cache_paths = None

    # --------------------------------------------------------------------------
    @classmethod
    def _init(cls, timing=False):
        &#34;&#34;&#34;Initializes the Data object instance with the data contained in the
        data_loader object

        Parameters
        ----------
        timing : bool
            (default is False) if True, the time it takes to initialize the Data
            object instance is printed
        &#34;&#34;&#34;
        t0 = time.time()
        cls._init_study_paths(timing=timing)
        cls._init_image_paths(timing=timing)
        cls._init_map(timing=timing)
        if cls._load_cache and not cls._cache:
            cls._init_cache(timing=timing)
        elif cls._cache and not cls._load_cache:
            cls._generate_label_map(timing=timing)
            cls._cache_labels(timing=timing)
        elif cls._cache and cls._load_cache:
            cls._init_cache(timing=timing)
            cls._cache_labels(timing=timing)
        else:
            cls._generate_label_map(timing=timing)
        cls._init_labels(timing=timing)
        cls._init_stats(timing=timing)

        if timing:
            cls.timing(t0, &#34;total _init&#34;)

    # --------------------------------------------------------------------------
    @classmethod
    def _init_study_paths(cls, timing=False):
        &#34;&#34;&#34;Initializes the study paths of the Data object instance. O(n) time

        Parameters
        ----------
        timing : bool
            (default is False) if True, the time it takes to initialize the
            study paths is printed
        &#34;&#34;&#34;
        t0 = time.time()
        study_list = []
        if cls._caselist_path is None:
            if cls.dl.data_paths is None or len(cls.dl.data_paths) == 0:
                print(&#34;no study files loaded&#34;)
                return
            # load the sorted study from list of paths
            for path in cls.dl.data_paths:  # iterate through each path
                study = sorted(
                    os.listdir(path)
                )  # get list of studies in the path, sorted
                study_list.append(study)  # add the study to the list of studies
            # loop to create the list of study paths
            for i in range(0, len(study_list)):  # iterate through each study
                study_id = 0  # initialize the study id
                for _ in study_list[i]:
                    #  append the root path to each study
                    study_list[i][study_id] = (
                        cls.dl.data_paths[i] + study_list[i][study_id]
                    )
                    study_id = study_id + 1
            cls._study_paths = sorted(
                [item for sublist in study_list for item in sublist]
            )
        else:
            with open(cls._caselist_path, &#34;r&#34;) as f:
                # read each line which is a path
                for path in f:
                    path = path.strip()
                    if path != &#34;&#34;:
                        study_path = os.path.dirname(path)
                        cls._study_paths.append(study_path)
            # remove any duplicates and sort the list
            cls._study_paths = sorted(list(set(cls._study_paths)))
        if timing is True:
            cls.timing(t0, &#34;load_studies&#34;)

    # --------------------------------------------------------------------------
    @classmethod
    def _init_map(cls, timing=False):
        &#34;&#34;&#34;Initializes the map of labels from the csv files, which is used
        to build a sop_uid to label dictionary. O(n) time complexity.

        Parameters
        ----------
        timing : bool
            (default is False) if True, the time it takes to initialize the
            map is printed
        &#34;&#34;&#34;
        t0 = time.time()

        if cls.dl.csv_paths is None or len(cls.dl.csv_paths) == 0:
            print(&#34;no csv files loaded&#34;)
            return
        # go through each csv file and load the map from it
        for path in cls.dl.csv_paths:
            with open(path, &#34;r&#34;) as f:
                lines = f.readlines()
                for line in lines:
                    values = line.split(&#34;,&#34;)
                    study_id = values[0]
                    lat = values[1]
                    label = values[2].strip()
                    cls._label_mapping_dict[study_id + &#34;_&#34; + lat] = label
        if timing is True:
            cls.timing(t0, &#34;csv_to_map&#34;)

    # --------------------------------------------------------------------------
    @classmethod
    def _init_image_paths(cls, timing=False):
        &#34;&#34;&#34;Initializes the image paths of the Data object instance. O(n) where
        n is the number of subdirectories in each study path.

        Parameters
        ----------
        timing : bool
            (default is False) if True, the time it takes to initialize the
            image paths is printed
        &#34;&#34;&#34;
        t0 = time.time()
        if cls._caselist_path is None:
            # use the path to each study and get the list of images
            for current_path in cls.dl.data_paths:
                # walk through each study
                for path, currentDirectory, files in os.walk(current_path):
                    # iterate through each image in the study
                    for file in files:
                        # if it is a 2D or 3D image, add it to the list of images
                        if file.startswith(
                            cls.dl.dicom_2d_substring
                        ) or file.startswith(cls.dl.dicom_3d_substring):
                            cls._image_paths.append(path + &#34;/&#34; + str(file))
                cls._image_paths = sorted(cls._image_paths)
        else:
            # open the caselist file and read each line which is a path and
            # add it to the list of image paths and then sort the list
            with open(cls._caselist_path, &#34;r&#34;) as f:
                for path in f:
                    path = path.strip()
                    if path != &#34;&#34;:
                        cls._image_paths.append(path)
            cls._image_paths = sorted(cls._image_paths)
        if timing is True:
            cls.timing(t0, &#34;load_images&#34;)

    # --------------------------------------------------------------------------
    @classmethod
    def _generate_label_map(cls, timing=False):
        &#34;&#34;&#34;Generates the label map of the Data object instance. O(n) where n
        is the number of images in the Data object instance.

        Parameters
        ----------
        timing : bool
            (default is False) if True, the time it takes to generate the
            label map is printed
        &#34;&#34;&#34;
        t0 = time.time()
        image_id = 0
        for path in cls._image_paths:
            if (
                os.path.basename(path).startswith(cls.dl.dicom_2d_substring)
                or cls.dl.dicom_2d_substring == &#34;&#34;
            ):
                ds = dicom.filereader.dcmread(
                    path,
                    stop_before_pixels=True,
                    specific_tags=[
                        &#34;ImageLaterality&#34;,
                        cls.dl.patient_identifier,
                        cls.dl.cancer_identifier,
                        &#34;StudyInstanceUID&#34;,
                    ],
                )
                image_laterality = ds.get(&#34;ImageLaterality&#34;)
            else:
                ds = dicom.filereader.dcmread(
                    path,
                    stop_before_pixels=True,
                    specific_tags=[
                        &#34;SharedFunctionalGroupsSequence&#34;,
                        cls.dl.patient_identifier,
                        cls.dl.cancer_identifier,
                        &#34;StudyInstanceUID&#34;,
                    ],
                )
                image_laterality = (
                    ds.SharedFunctionalGroupsSequence[0]
                    .FrameAnatomySequence[0]
                    .FrameLaterality
                )
            can_id = ds.get(cls.dl.cancer_identifier)
            # make dictionary of labels based off of ImageID as index
            label = cls._label(can_id, image_laterality)
            pat_id = ds.get(cls.dl.patient_identifier)
            cls.pat_id_to_label_dict[pat_id] = label
            cls._labels[image_id] = label

            image_id += 1
            if timing is True:
                if image_id % 1000 == 0:
                    cls.timing(t0, str(image_id))
        if timing is True:
            cls.timing(t0, &#34;load_labels&#34;)

    # --------------------------------------------------------------------------
    @classmethod
    def _init_labels(cls, timing=False):
        &#34;&#34;&#34;Initializes the labels of the Data object instance. O(n)

        Parameters
        ----------
        timing : bool
            (default is False) if True, the time it takes to initialize the
            labels is printed
        &#34;&#34;&#34;
        t0 = time.time()
        cls.total_2d_cancer = 0
        cls.total_3d_cancer = 0
        cls.total_2d_preindex = 0
        cls.total_3d_preindex = 0
        cls.total_2d_noncancer = 0
        cls.total_3d_noncancer = 0
        # loop over the image_paths and generate the counts of all the possible
        # filtered scenarios
        for i in range(0, len(cls._image_paths)):
            path = cls._image_paths[i]
            label = cls._labels[i]
            if (
                os.path.basename(path).startswith(cls.dl.dicom_2d_substring)
                or cls.dl.dicom_2d_substring == &#34;&#34;
            ):
                if label == &#34;IndexCancer&#34;:
                    cls.total_2d_cancer += 1
                elif label == &#34;PreIndexCancer&#34;:
                    cls.total_2d_preindex += 1
                elif label == &#34;NonCancer&#34;:
                    cls.total_2d_noncancer += 1
            else:
                if label == &#34;IndexCancer&#34;:
                    cls.total_3d_cancer += 1
                elif label == &#34;PreIndexCancer&#34;:
                    cls.total_3d_preindex += 1
                elif label == &#34;NonCancer&#34;:
                    cls.total_3d_noncancer += 1
        if timing is True:
            cls.timing(t0, &#34;generate_counts&#34;)

    # --------------------------------------------------------------------------
    @property
    def labels(cls):
        &#34;&#34;&#34;Returns the labels of the Data object instance&#34;&#34;&#34;
        return cls._labels

    @classmethod
    def _init_stats(cls, timing=False):
        &#34;&#34;&#34;Initializes the statistics of the Data object instance

        Parameters
        ----------
        timing : bool
            (default is False) if True, the time it takes to initialize the
            statistics is printed
        &#34;&#34;&#34;
        t0 = time.time()
        cls._stats = {}
        tot_all_dicoms = 0
        tot_all_2d = 0
        tot_all_3d = 0
        files_2d_per_study = {}
        files_3d_per_study = {}
        # loop over the image_paths and generate the counts of all the possible
        # scenarios
        for path in cls._image_paths:
            for study_folder in cls.dl.study_folder_names:
                if study_folder in path:
                    # counting the 2d Dicom files per study
                    if (
                        os.path.basename(path).startswith(cls.dl.dicom_2d_substring)
                        or cls.dl.dicom_2d_substring == &#34;&#34;
                    ):
                        tot_all_2d += 1
                        files_2d_per_study[study_folder] = (
                            files_2d_per_study.get(study_folder, 0) + 1
                        )
                    #  counting the 3d Dicom files per study
                    elif (
                        os.path.basename(path).startswith(cls.dl.dicom_3d_substring)
                        or cls.dl.dicom_3d_substring == &#34;&#34;
                    ):
                        tot_all_3d += 1
                        files_3d_per_study[study_folder] = (
                            files_3d_per_study.get(study_folder, 0) + 1
                        )
                    tot_all_dicoms += 1
        # Using the counts from above, generate the statistics for each study
        # as well as the global statistics
        for i in range(0, len(cls.dl.data_paths)):
            folder = str(cls.dl.study_folder_names[i])
            if folder in files_2d_per_study:
                _2D = files_2d_per_study[folder]
            else:
                _2D = 0
            if folder in files_3d_per_study:
                _3D = files_3d_per_study[folder]
            else:
                _3D = 0
            total = _2D + _3D
            case = {&#34;total&#34;: total, &#34;3D&#34;: _3D, &#34;2D&#34;: _2D}
            cls._stats[folder] = case
            # using SimpleNamespace to give dot notation access to the stats
            cls._stats[folder] = SimpleNamespace(**cls._stats[folder])
        cls._stats[&#34;total_all_dicoms&#34;] = tot_all_dicoms
        cls._stats[&#34;total_2d_all&#34;] = tot_all_2d
        cls._stats[&#34;total_3d_all&#34;] = tot_all_3d
        cls._stats[&#34;total_2d_cancer&#34;] = cls.total_2d_cancer
        cls._stats[&#34;total_2d_preindex&#34;] = cls.total_2d_preindex
        cls._stats[&#34;total_2d_noncancer&#34;] = cls.total_2d_noncancer
        cls._stats[&#34;total_3d_cancer&#34;] = cls.total_3d_cancer
        cls._stats[&#34;total_3d_preindex&#34;] = cls.total_3d_preindex
        cls._stats[&#34;total_3d_noncancer&#34;] = cls.total_3d_noncancer
        cls._stats[&#34;total_cancer&#34;] = cls.total_2d_cancer + cls.total_3d_cancer
        cls._stats[&#34;total_preindex&#34;] = cls.total_2d_preindex + cls.total_3d_preindex
        cls._stats[&#34;total_noncancer&#34;] = cls.total_2d_noncancer + cls.total_3d_noncancer
        cls._stats[&#34;total_no_label&#34;] = tot_all_dicoms - (
            cls.total_3d_noncancer
            + cls.total_2d_noncancer
            + cls.total_3d_preindex
            + cls.total_2d_preindex
            + cls.total_3d_cancer
            + cls.total_2d_cancer
        )
        # Using SimpleNamespace to give nested dot notation access to the stats
        cls._stats = SimpleNamespace(**cls._stats)
        if timing is True:
            cls.timing(t0, &#34;generate_stats&#34;)

    # --------------------------------------------------------------------------
    @classmethod
    def _save_pickle(cls, path, data, timing=False):
        &#34;&#34;&#34;Saves the data to a pickle file

        Parameters
        ----------
        path : str
            the path and name of the pickle file to save the data to
        data : dict
            the data to save to the pickle file
        timing : bool
            (default is False) if True, the time it takes to save the data is
            printed
        &#34;&#34;&#34;
        t0 = time.time()
        if not os.path.isfile(path):
            with open(path, &#34;wb&#34;) as file:
                pickle.dump(data, file)
            file.close()
        else:
            pickle_file = open(path, &#34;wb&#34;)
            pickle.dump(data, pickle_file)
            pickle_file.close()

        if timing is True:
            cls.timing(t0, &#34;save_pickle&#34;)

    # --------------------------------------------------------------------------
    @classmethod
    def _load_pickle(cls, path, timing=False):
        &#34;&#34;&#34;Loads a pickle file from the given path

        Parameters
        ----------
        path : str
            the path to the pickle file
        timing : bool
            (default is False) if True, the time it takes to load the pickle file
            is printed
        &#34;&#34;&#34;
        t0 = time.time()
        pickle_file = open(path, &#34;rb&#34;)
        result = pickle.load(pickle_file)
        pickle_file.close()
        if timing is True:
            cls.timing(t0, &#34;load_pickle&#34;)
        return result

    # --------------------------------------------------------------------------
    @classmethod
    def _cache_labels(cls, timing=False):
        &#34;&#34;&#34;Caches the _labels and the sopuid_to_labels of the Data object
        instance

        Parameters
        ----------
        timing : bool
            (default is False) if True, the time it takes to cache the labels is
             printed
        &#34;&#34;&#34;
        t0 = time.time()

        cls._save_pickle(cls.dl.cache_paths[0], cls._labels)
        cls._save_pickle(cls.dl.cache_paths[1], cls.pat_id_to_label_dict)

        if timing is True:
            cls.timing(t0, &#34;save_pickle&#34;)

    # --------------------------------------------------------------------------
    @classmethod
    def _init_cache(cls, timing=False):
        &#34;&#34;&#34;Initializes the cache of the Data object instance

        Parameters
        ----------
        timing : bool
            (default is False) if True, the time it takes to initialize the
            cache is printed
        &#34;&#34;&#34;
        t0 = time.time()
        cls._labels = cls._load_pickle(cls.dl.cache_paths[0])
        cls.pat_id_to_label_dict = cls._load_pickle(cls.dl.cache_paths[1])
        if timing is True:
            cls.timing(t0, &#34;load_pickle&#34;)

    # --------------------------------------------------------------------------
    @classmethod
    def path(
        cls,
        image_id: int = None,
        dicom_name: str = None,
        path: str = None,
        study_instance_uid: str = None,
        study_key: int = None,
        timing=False,
    ) -&gt; str:
        &#34;&#34;&#34;Returns the path to the image, given one of the several ids

        Parameters
        ----------
        image_id : int
            (default is None) the id of the image
        dicom_name : str
            (default is None) the name of the dicom file
        path : str
            (default is None) the path of the image
        study_instance_uid : str
            (default is None) the study instance uid of the image
        study_key : int
            (default is None) the key of the study
        timing : bool
            (default is False) if True, the time it takes to find the path is printed

        Returns
        -------
        path : str
            the path of the image
        &#34;&#34;&#34;
        t0 = time.time()
        if image_id is not None:
            path = cls._image_paths[image_id]
        elif dicom_name is not None:
            path = &#34;&#34;.join([s for s in cls._image_paths if dicom_name in s])
        elif path is not None:
            path = path
        elif study_instance_uid is not None:
            file_id = [
                idx for idx, s in enumerate(cls._study_paths) if study_instance_uid in s
            ][0]
            path = cls._study_paths[file_id]
        elif study_key is not None:
            path = cls._study_paths[study_key]
        else:
            return (
                &#34;Error: No valid image_id, dicom_name, path, &#34;
                &#34;study_instance_uid or study_key was specified &#34;
            )
        if timing is True:
            cls.timing(t0, &#34;get_path&#34;)
        return path

    # --------------------------------------------------------------------------
    @classmethod
    def _dicom(
        cls,
        dicom_name: str = None,
        image_id: int = None,
        dicom_path: str = None,
        pixels=False,
        dicom_header=False,
        timing=False,
    ):
        &#34;&#34;&#34;Returns the dicom object of the image with the given path

        Parameters
        ----------
        dicom_name : str
            (default is None) the name of the dicom file
        image_id : int
            (default is None) the id of the image
        dicom_path : str
            (default is None) the path of the dicom file
        pixels : bool
            (default is False) if True, the pixel data of the image is returned
        dicom_header : bool
            (default is False) if True, the dicom header of the image is
            returned
        timing : bool
            (default is False) if True, the time it takes to load the dicom
            is printed

        Returns
        -------
        dicom : pydicom.dicom.Dataset
            the dicom object of the image
        &#34;&#34;&#34;
        t0 = time.time()

        if image_id is not None:
            img_path = cls.path(image_id=image_id)
            if cls._validate_path(img_path) is False:
                return &#34;path not valid&#34;, None
        elif dicom_path is not None:
            if cls._validate_path(dicom_path) is False:
                return &#34;path not valid&#34;, None
            img_path = dicom_path
        elif dicom_name is not None:
            img_path = cls.path(dicom_name=dicom_name)
            if cls._validate_path(img_path) is False:
                return &#34;path not valid&#34;, None
        else:
            print(
                &#34;Error: No valid dicom_name, image_id, dicom_path or &#34;
                &#34;dicom_name was specified&#34;
            )
            return &#34;None&#34;, None
        if dicom_header and pixels:
            ds = dicom.filereader.dcmread(img_path, force=True)
        elif pixels:
            ds = dicom.filereader.dcmread(
                img_path, force=True, specific_tags=cls.dl.dicom_tags
            )
        else:
            ds = dicom.filereader.dcmread(img_path, force=True, stop_before_pixels=True)
        if timing is True:
            cls.timing(t0, &#34;_get_dicom&#34;)
        return ds

    # --------------------------------------------------------------------------
    @classmethod
    def _validate_path(
        cls,
        path,
        _2d=True,
        _3d=True,
    ) -&gt; bool:
        &#34;&#34;&#34;Checks if the path is valid

        Parameters
        ----------
        path : str
            the path to check
        _2d : bool
            (default is True) if True, the path must be a 2D image
        _3d : bool
            (default is True) if True, the path must be a 3D image

        Returns
        -------
        valid : bool
            if True, the path is valid and can be used, otherwise it is not
        &#34;&#34;&#34;
        if _2d and _3d:
            if (
                os.path.basename(path).startswith(cls.dl.dicom_3d_substring)
                or os.path.basename(path).startswith(cls.dl.dicom_2d_substring)
                or cls.dl.dicom_3d_substring == &#34;&#34;
                or cls.dl.dicom_2d_substring == &#34;&#34;
            ):
                return True
        elif _2d:
            if (
                os.path.basename(path).startswith(cls.dl.dicom_2d_substring)
                or cls.dl.dicom_2d_substring == &#34;&#34;
            ):
                return True
        elif _3d:
            if (
                os.path.basename(path).startswith(cls.dl.dicom_3d_substring)
                or cls.dl.dicom_3d_substring == &#34;&#34;
            ):
                return True
        return False

    # --------------------------------------------------------------------------
    @classmethod
    def _files_in_series(
        cls,
        path=None,
        study_instance_uid=None,
        _2d=True,
        _3d=True,
        labels=None,
        manufacturer=None,
        timing=False,
    ) -&gt; list:
        &#34;&#34;&#34;Returns the files in the series with the given path

        Parameters
        ----------
        path : str,
            (default is None) the path of the series
        study_instance_uid : str
            (default is None) the study instance uid of the series
        timing : bool
            (default is False) if True, the time it takes to load the dicom
            is printed

        Returns
        -------
        files : list
            the files in the series
        &#34;&#34;&#34;
        t0 = time.time()
        if path is not None:
            file_names = os.listdir(path)
        else:
            idx = [
                idx for idx, s in enumerate(cls._study_paths) if study_instance_uid in s
            ][0]
            file_names = os.listdir(cls._study_paths[idx])
        file_names = [f for f in file_names if cls._validate_path(f, _2d, _3d)]
        if labels is not None:
            temp = []
            for f in file_names:
                img_idx = cls._image_id(dicom_name=f, timing=timing)
                if img_idx != -1:
                    temp.append(f)
            file_names = temp.copy()
        if manufacturer is not None:
            temp = []
            for f in file_names:
                ds = cls._dicom(
                    dicom_name=f, pixels=False, dicom_header=False, timing=timing
                )
                if ds.Manufacturer == manufacturer:
                    temp.append(f)
            file_names = temp.copy()
        if timing is True:
            cls.timing(t0, &#34;get_file_names_in_series&#34;)
        return file_names

    # --------------------------------------------------------------------------
    @classmethod
    def _image_id(cls, dicom_name, timing=False) -&gt; int:
        &#34;&#34;&#34;Returns the image id of the image with the given dicom name

        Parameters
        ----------
        dicom_name : str
            the dicom name of the image
        timing : bool
            (default is False) if True, the time it takes to load the dicom
            is printed

        Returns
        -------
        image_id : int
            the image id of the image
        &#34;&#34;&#34;
        t0 = time.time()
        index = -1
        temp_index = 0
        for img in cls._image_paths:
            if dicom_name in img:
                index = temp_index
                break
            temp_index += 1
        if timing is True:
            cls.timing(t0, &#34;image_id&#34;)
        return index

    # --------------------------------------------------------------------------
    @classmethod
    def _study_key(cls, study_instance_uid, timing=False) -&gt; int:
        &#34;&#34;&#34;Returns the study key of the study with the given study instance uid

        Parameters
        ----------
        study_instance_uid : str
            the study instance uid of the study
        timing : bool
            (default is False) if True, the time it takes to load the dicom
            is printed

        Returns
        -------
        study_key : int
            the study key of the study
        &#34;&#34;&#34;
        t0 = time.time()
        index = [
            idx for idx, s in enumerate(cls._study_paths) if study_instance_uid in s
        ][0]
        if timing is True:
            cls.timing(t0, &#34;study_key&#34;)
        return index

    # --------------------------------------------------------------------------
    @classmethod
    def _label(cls, cancer_id, image_laterality, timing=False) -&gt; str:
        &#34;&#34;&#34;Returns the label of the image with the given study instance uid and
         image laterality

        Parameters
        ----------
        cancer_id : str
            the study instance uid of the study
        image_laterality : str
            the image laterality of the image
        timing : bool
            (default is False) if True, the time it takes to load the dicom
            is printed

        Returns
        -------
        label : str
            the label of the image
        &#34;&#34;&#34;
        t0 = time.time()
        key = str(cancer_id) + &#34;_&#34; + str(image_laterality)
        if key in cls._label_mapping_dict:
            label = cls._label_mapping_dict[key]
        elif str(cancer_id) + &#34;_&#34; + &#34;None&#34; in cls._label_mapping_dict:
            label = cls._label_mapping_dict[str(cancer_id) + &#34;_&#34; + &#34;None&#34;]
        elif (
            (str(cancer_id) + &#34;_&#34; + &#34;L&#34; in cls._label_mapping_dict)
            or (str(cancer_id) + &#34;_&#34; + &#34;R&#34; in cls._label_mapping_dict)
            or (str(cancer_id) + &#34;_&#34; + &#34;B&#34; in cls._label_mapping_dict)
        ):
            label = &#34;NonCancer&#34;
        else:
            label = &#34;No Label Information&#34;

        if timing is True:
            cls.timing(t0, &#34;get_label&#34;)
        return label

    # --------------------------------------------------------------------------
    @classmethod
    def to_text_file(cls, file_path=None, file_name=None):
        &#34;&#34;&#34;Writes each path from the image_paths list to a text file each
        separated by a new line

        Parameters
        ----------
        file_name : str
            the name of the file to write to
        file_path : str
            the path to the file to write to

        Returns
        -------
        file_path : str
            the path to the file that was written to
        &#34;&#34;&#34;
        if file_path is None:
            # get current working directory
            file_path = os.getcwd() + &#34;/&#34;
        if file_name is None:
            file_name = &#34;image_paths.txt&#34;
        with open(file_path + file_name, &#34;w&#34;) as f:
            for path in cls._image_paths:
                # check if it is the last line in the file and if it is, don&#39;t
                # add a new line
                if path != cls._image_paths[-1]:
                    f.write(path + &#34;\n&#34;)
                else:
                    f.write(path)
        return file_path + file_name

    # --------------------------------------------------------------------------
    @classmethod
    def get_label(cls, cancer_id, timing=False):
        &#34;&#34;&#34;Returns the label of the image with the given sop uid

        Parameters
        ----------
        cancer_id : str
            the sop uid of the image
        timing : bool
            (default is False) if True, the time it takes to load the dicom
            is printed

        Returns
        -------
        label : str
            the label of the image
        &#34;&#34;&#34;
        t0 = time.time()
        if cancer_id in cls.pat_id_to_label_dict:
            label = cls.pat_id_to_label_dict[cancer_id]
        else:
            label = &#34;No Label Information&#34;
        if timing is True:
            cls.timing(t0, &#34;get_label&#34;)
        return label

    # --------------------------------------------------------------------------
    @classmethod
    def get_study(
        cls,
        study_instance_uid: str = None,
        study_key: int = None,
        verbose=False,
        timing=False,
    ) -&gt; SimpleNamespace:
        &#34;&#34;&#34;Returns the study with the given study instance uid or study key

        Parameters
        ----------
        study_instance_uid : str
            (default is None, this or the ID need to be set)
            Uses the StudyInstanceUID to locate the study information and returns
            data as dictionary
        study_key : int
            (default is None, this or the study_instance_uid needs to be set)
            Uses the location of a study which is based off of its index in the
            sorted list of all studies
        verbose : bool
            (default is False) If True, will include additional information
            about the study such as the number of 2D and 3D dicoms in study
        timing : bool
            (default is False) Sets timing flag, if true will time execution time
             of method, else will not

        Returns
        ------
        study : SimpleNamespace
            {&#39;directory&#39;: XX, &#39;images&#39;: [imagefile1, imagefile2, ...]}
            iff (verbose==True) =&gt; info&#39;: {&#39;3D_count&#39;: XX, &#39;2D_count&#39;: XX ..and others}
        &#34;&#34;&#34;
        _2d = True
        _3d = True
        lab = []
        t0 = time.time()
        if study_instance_uid is not None:
            uid_path = cls.path(study_instance_uid=study_instance_uid, timing=timing)
            file_id = cls._study_key(uid_path, timing=timing)
        elif study_key is not None:
            uid_path = cls.path(study_key=study_key, timing=timing)
            study_instance_uid = os.path.basename(uid_path)
            file_id = study_key
        else:
            raise ValueError(&#34;Either study_instance_uid or study_key must be set&#34;)
        if cls._filtered_flags != {}:  # if there are filters
            _2d = cls._filtered_flags[&#34;2D&#34;]
            _3d = cls._filtered_flags[&#34;3D&#34;]
            lab = cls._filtered_flags[&#34;labels&#34;]
            man = cls._filtered_flags[&#34;manufacturers&#34;]
        image_files = cls._files_in_series(
            path=uid_path, _2d=_2d, _3d=_3d, labels=lab, timing=timing
        )
        if cls.dl.dicom_3d_substring != &#34;&#34;:
            files_3d = [i for i in image_files if cls.dl.dicom_3d_substring in i]
        else:
            # if there is no 3d substring, then all files are 3d
            files_3d = [image_files for i in image_files]
        if cls.dl.dicom_2d_substring != &#34;&#34;:
            files_2d = [i for i in image_files if cls.dl.dicom_2d_substring in i]
        else:
            # if there is no 2d substring, then all files are 2d
            files_2d = [image_files for i in image_files]
        # get a list of image ids from each of the files
        image_ids = [cls._image_id(i) for i in image_files]
        # remove all image_ids tha are -1
        image_ids = [i for i in image_ids if i != -1]
        # use the images ids to get the image labels
        image_labels = [cls._labels[i] for i in image_ids]
        # count each of the types in the image labels
        label_counts = Counter(image_labels)

        if verbose:
            info = {
                &#34;total&#34;: len(files_3d) + len(files_2d),
                &#34;3D count&#34;: len(files_3d),
                &#34;2D count&#34;: len(files_2d),
                &#34;label counts&#34;: label_counts,
            }
        else:
            info = None

        study = {
            &#34;directory&#34;: uid_path,
            &#34;study_uid&#34;: study_instance_uid,
            &#34;study_key&#34;: file_id,
            &#34;images&#34;: image_files,
            &#34;info&#34;: info,
        }
        dot_dictionary = SimpleNamespace(**study)
        if timing is True:
            cls.timing(t0, &#34;get_study&#34;)
        return dot_dictionary

    # --------------------------------------------------------------------------
    @classmethod
    def get_image(
        cls,
        image_id=None,
        dicom_name=None,
        path=None,
        pixels=True,
        dicom_header=False,
        timing=False,
    ) -&gt; SimpleNamespace:
        &#34;&#34;&#34;Returns the image with the given image id or dicom name or path

        Parameters
        ----------
        image_id : int
            (default is None, this or the Dicom_ID or path need to be set)
            Uses the image_id to fetch Dicom and returns the specified data
        dicom_name : str
            (default is None, this or the image_id or path need to be set)
            Uses the dicom_name to fetch Dicom, and returns the specified  data
        path : str
            (default is None, this or the image_id or dicom_name need to be set)
            Uses the path to fetch Dicom, and returns the specified data
        pixels : bool
            (default is True) If True will return the pixel array of Dicom,
            else will return None
        dicom_header : bool
            (default is False) If True will return the dicom header as a
            dictionary, else will return None
        timing : bool
            (default is False)
            If true will time execution of method, else will not

        Returns
        ------
        image : SimpleNamespace
            [np.array just the pixels or None if pixels=False, info]
            info is dictionary:
            {&#39;label&#39;: LABELS.Cancer, &#39;filepath&#39;:... &#39;shape&#39;...}
        &#34;&#34;&#34;
        t0 = time.time()
        ds = cls._dicom(
            dicom_name=dicom_name,
            image_id=image_id,
            dicom_path=path,
            pixels=pixels,
            dicom_header=dicom_header,
            timing=timing,
        )
        img = None
        study_instance_uid = None
        img_path = cls.path(image_id=image_id, dicom_name=dicom_name, path=path)
        if os.path.basename(img_path).startswith(cls.dl.dicom_3d_substring):
            ds1 = dicom.filereader.dcmread(
                img_path,
                stop_before_pixels=True,
                specific_tags=[
                    &#34;PatientID&#34;,
                    &#34;InstanceNumber&#34;,
                    &#34;SharedFunctionalGroupsSequence&#34;,
                    &#34;StudyInstanceUID&#34;,
                ],
            )
            study_instance_uid = ds1.StudyInstanceUID
            image_laterality = (
                ds1.SharedFunctionalGroupsSequence[0]
                .FrameAnatomySequence[0]
                .FrameLaterality
            )
            image_shape = (int(ds.NumberOfFrames), int(ds.Rows), int(ds.Columns))
        else:
            ds1 = dicom.filereader.dcmread(
                img_path,
                stop_before_pixels=True,
                specific_tags=[
                    &#34;PatientID&#34;,
                    &#34;InstanceNumber&#34;,
                    &#34;ImageLaterality&#34;,
                    &#34;StudyInstanceUID&#34;,
                ],
            )
            study_instance_uid = ds1.StudyInstanceUID
            image_laterality = ds1.get(&#34;ImageLaterality&#34;)
            image_shape = (int(ds.Rows), int(ds.Columns))

        # img_index = cls._image_id(os.path.basename(img_path))
        # label = cls._labels[int(img_index)]

        # get the dicom name
        sop_uid = os.path.basename(img_path)
        if cls.dl.dicom_3d_substring != &#34;&#34; and cls.dl.dicom_2d_substring != &#34;&#34;:
            # remove the dicom_3d_substring or dicom_2d_substring from the beginning
            sop_uid = sop_uid.replace(cls.dl.dicom_3d_substring + &#34;.&#34;, &#34;&#34;)
            sop_uid = sop_uid.replace(cls.dl.dicom_2d_substring + &#34;.&#34;, &#34;&#34;)

        # get the image label
        label = cls.get_label(sop_uid)

        if pixels is True:
            img = ds.pixel_array
        if dicom_header is False:
            ds = None
        dictionary = {
            &#34;filePath&#34;: img_path,
            &#34;SOPInstanceUID&#34;: sop_uid,
            &#34;StudyInstanceUID&#34;: study_instance_uid,
            &#34;PatientID&#34;: ds1.PatientID,
            &#34;InstanceNumber&#34;: ds1.InstanceNumber,
            &#34;label&#34;: label,
            &#34;imageLaterality&#34;: image_laterality,
            &#34;shape&#34;: image_shape,
            &#34;metadata&#34;: ds,
            &#34;pixels&#34;: img,
        }
        dot_dictionary = SimpleNamespace(**dictionary)
        if timing:
            cls.timing(t0, &#34;get_image&#34;)
        return dot_dictionary

    # --------------------------------------------------------------------------
    @classmethod
    def next_image(
        cls, _2d=False, _3d=False, label=None, randomize=False, timing=False
    ) -&gt; Generator[SimpleNamespace, None, None]:
        &#34;&#34;&#34;Generator to filter and return iteratively all the filtered images in
        the dataset

        Parameters
        ----------
        _2d : bool
           (default is False, this or _3D or both needs to be set to True)
           Filter flag used to add 2D images to returned set of Dicoms
        _3d : bool
           (default is False, this or _2D or both needs to be set to True)
           Filter flag used to add 3D images to returned set of Dicoms
        label : str
           (default is None which is all labeled images)
           options are IndexCancer, NonCancer, PreIndexCancer
        randomize : bool
           (default is False) If True will randomize the order of the
           returned images
        timing : bool
           (default is False) If true will time execution of method,
           else will not

        Returns
        -------
        image : generator
           [np.array just the pixels, info]
           info is dictionary: {&#39;label&#39;: LABELS.Cancer, &#39;filepath&#39;:... &#39;shape&#39;...}

        &#34;&#34;&#34;
        t0 = time.time()
        generator_map = {}
        image_index_list = {}
        if label is not None:
            for i in range(len(cls._labels)):
                if cls._labels[i] == label:
                    image_index_list[i] = cls._image_paths[i]
        else:
            for i in range(len(cls._labels)):
                image_index_list[i] = cls._image_paths[i]

        if _2d and _3d:
            for k, v in image_index_list.items():
                generator_map[k] = v
        elif _2d:
            for k, v in image_index_list.items():
                if os.path.basename(v).startswith(cls.dl.dicom_2d_substring):
                    generator_map[k] = v
                elif cls.dl.dicom_2d_substring == &#34;&#34;:
                    generator_map[k] = v
        else:
            for k, v in image_index_list.items():
                if os.path.basename(v).startswith(cls.dl.dicom_3d_substring):
                    generator_map[k] = v

        # shuffle the generator
        dicoms = list(generator_map.items())
        if randomize is True:
            random.shuffle(dicoms)

        for k, v in dicoms:
            img_path = str(v)
            test_label = cls._labels[int(k)]
            if test_label == label or label is None:
                ds = cls.get_image(path=img_path)
                try:
                    yield ds
                except StopIteration:
                    break
            else:
                continue
        if timing:
            cls.timing(t0, &#34;next_image_all&#34;)

    # --------------------------------------------------------------------------
    @classmethod
    def filter_data(
        cls,
        _2d=True,
        _3d=True,
        shapes: list = None,
        row_max: int = None,
        row_min: int = None,
        col_max: int = None,
        col_min: int = None,
        frames_max: int = None,
        frames_min: int = None,
        age_range: list = None,
        labels: list = None,
        studies: list = None,
        manufacturers: list = None,
        timing=False,
    ):
        &#34;&#34;&#34;Filters the dataset to include only Dicoms that match the specified
        filter flags. Configures internal class data in a way that all the Data
        methods work the same, but only will be on the filtered data.
        To reset the filtered data to the original dataset, use the
        reset_data method.

        Parameters
        ----------
        _2d : int
            (default is True, includes 2D images)
            Filter flag used to remove 2D images
        _3d : str
            (default is True, includes 3D images)
            Filter flag used to remove 3D images
        shapes: list[&#39;(X1,Y1)&#39;, &#39;(X2,Y2)&#39;, ..., (Xn,Yn,Zn)&#39;]
            (default is None, includes all shapes)
            specify the shapes of the images to include
        row_max: int
            (default is None, includes all rows)
            Filter flag used to remove images with rows greater than the
            specified value
        row_min: int
            (default is None, includes all rows)
            Filter flag used to remove images with rows less than the
            specified value
        col_max: int
            (default is None, includes all columns)
            Filter flag used to remove images with columns greater than the
            specified value
        col_min: int
            (default is None, includes all columns)
            Filter flag used to remove images with columns less than the
            specified value
        frames_max: int
            (default is None, includes all frames)
            Filter flag used to remove images with frames greater than the
            specified value
        frames_min: int
            (default is None, includes all frames)
            Filter flag used to remove images with frames less than the
            specified value
        age_range: list[min, max]
            (Default is None, include all ages)
            specify the age range in years to filter images by age
        labels: list
            (default is None, includes all labels)
            specify the labels of the images to include
        studies: list
            (default is None, includes all studies)
            specify the studies of the images to include
        manufacturers: list
            (default is None, includes all manufacturers)
            specify the manufacturers of the images to include
        timing: bool
            (default is False) If true will time execution of method,
            else will not
        &#34;&#34;&#34;
        t0 = time.time()
        # build the filtered_flags dictionary
        cls._filtered_flags = {
            &#34;2D&#34;: _2d,
            &#34;3D&#34;: _3d,
            &#34;shapes&#34;: shapes,
            &#34;row_max&#34;: row_max,
            &#34;row_min&#34;: row_min,
            &#34;col_max&#34;: col_max,
            &#34;col_min&#34;: col_min,
            &#34;frames_max&#34;: frames_max,
            &#34;frames_min&#34;: frames_min,
            &#34;age_range&#34;: age_range,
            &#34;labels&#34;: labels,
            &#34;studies&#34;: studies,
            &#34;manufacturers&#34;: manufacturers,
        }
        label_to_path_map = {}
        dimension_map = {}
        filtered_map = {}
        temp_labels = {}
        # remove the labels that are not in the filtered_flags first
        if labels is not None:
            for label in labels:
                for i in range(len(cls._labels)):
                    if cls._labels[i] == label:
                        temp_labels[i] = cls._labels[i]
                        label_to_path_map[i] = cls._image_paths[i]
        else:
            for i in range(len(cls._labels)):
                temp_labels[i] = cls._labels[i]
                label_to_path_map[i] = cls._image_paths[i]
        # remove the dimensions that are not in the filtered_flags
        if _2d and _3d:
            for k, v in label_to_path_map.items():
                if studies is not None:
                    for study in studies:
                        if study in v:
                            dimension_map[k] = v
                else:
                    dimension_map[k] = v
        elif _2d:
            for k, v in label_to_path_map.items():
                if (
                    os.path.basename(v).startswith(cls.dl.dicom_2d_substring)
                    or cls.dl.dicom_2d_substring == &#34;&#34;
                ):
                    if studies is not None:
                        for study in studies:
                            if study in v:
                                dimension_map[k] = v
                    else:
                        dimension_map[k] = v
        else:
            for k, v in label_to_path_map.items():
                if (
                    os.path.basename(v).startswith(cls.dl.dicom_3d_substring)
                    or cls.dl.dicom_3d_substring == &#34;&#34;
                ):
                    if studies is not None:
                        for study in studies:
                            if study in v:
                                dimension_map[k] = v
                    else:
                        dimension_map[k] = v
        # next filter by the shapes of the images
        if shapes is not None:
            pattern = &#34;&#34;
            for shape in shapes:
                print(f&#34;Filtering for shape: {shape}&#34;)
                if shape != shapes[-1]:
                    pattern += shape + &#34;|&#34;
                else:
                    pattern += shape
            count = 0
            for k, v in dimension_map.items():
                img_path = str(v)
                test_label = cls._labels[int(k)]
                if labels is None or labels.__contains__(test_label):
                    ds = dicom.filereader.dcmread(
                        img_path,
                        stop_before_pixels=True,
                        force=True,
                        specific_tags=[&#34;Columns&#34;, &#34;Rows&#34;, &#34;NumberOfFrames&#34;],
                    )
                    rows = ds.Rows
                    cols = ds.Columns
                    if os.path.basename(img_path).startswith(cls.dl.dicom_3d_substring):
                        frames = ds.NumberOfFrames
                        shape = str(
                            &#34;(&#34; + str(rows) + &#34;,&#34; + str(cols) + &#34;,&#34; + str(frames) + &#34;)&#34;
                        )
                    else:
                        shape = str(&#34;(&#34; + str(rows) + &#34;,&#34; + str(cols) + &#34;)&#34;)
                    if re.search(pattern, shape) is not None:
                        filtered_map[k] = v
                    if timing:
                        count += 1
                        if count % 100 == 0:
                            percentage_done = int(count / len(dimension_map) * 100)
                            print(f&#34;{percentage_done}% done&#34;)

        elif (
            shapes is None
            and (col_max is not None and row_max is not None)
            or (col_min is not None and row_min is not None)
        ):
            count = 0
            for k, v in dimension_map.items():
                img_path = str(v)
                test_label = cls._labels[int(k)]
                if labels is None or labels.__contains__(test_label):
                    ds = dicom.filereader.dcmread(
                        img_path,
                        stop_before_pixels=True,
                        force=True,
                        specific_tags=[&#34;Columns&#34;, &#34;Rows&#34;, &#34;NumberOfFrames&#34;],
                    )
                    rows = ds.Rows
                    cols = ds.Columns
                    frames = 1
                    if os.path.basename(img_path).startswith(cls.dl.dicom_3d_substring):
                        frames = ds.NumberOfFrames
                    if (
                        (col_min is None or col_min &lt;= cols)
                        and (col_max is None or cols &lt;= col_max)
                        and (row_min is None or row_min &lt;= rows)
                        and (row_max is None or rows &lt;= row_max)
                        and (frames_min is None or frames_min &lt;= frames)
                        and (frames_max is None or frames &lt;= frames_max)
                    ):
                        filtered_map[k] = v
                    if timing:
                        count += 1
                        percentage_done = count / len(dimension_map) * 100
                        if count % 1000 == 0:
                            print(f&#34;{percentage_done}% done&#34;)
        else:
            filtered_map = dimension_map

        # filter by the age range
        temp_map = {}
        count = 0
        if age_range is not None:
            # turning years into months to match how age is stored in dicom
            age_range[0] = int(age_range[0] * 12)
            age_range[1] = int(age_range[1] * 12)
            for k, v in filtered_map.items():
                img_path = str(v)
                test_label = cls._labels[int(k)]
                if labels is None or labels.__contains__(test_label):
                    ds = dicom.filereader.dcmread(
                        img_path,
                        stop_before_pixels=True,
                        force=True,
                        specific_tags=[&#34;PatientAge&#34;, &#34;PatientSex&#34;],
                    )
                    if ds.PatientAge is not None and ds.PatientAge != &#34;&#34;:
                        age = int(ds.PatientAge[:-1])
                        if age_range[0] &lt;= age &lt;= age_range[1]:
                            temp_map[k] = v
                    if timing:
                        count += 1
                        percentage_done = count / len(filtered_map) * 100
                        if count % 1000 == 0:
                            print(f&#34;{percentage_done}% done&#34;)
            filtered_map = temp_map

        # filter by manufacturer
        temp_map = {}
        count = 0
        if manufacturers is not None:
            for k, v in filtered_map.items():
                img_path = str(v)
                test_label = cls._labels[int(k)]
                if labels is None or labels.__contains__(test_label):
                    ds = dicom.filereader.dcmread(
                        img_path,
                        stop_before_pixels=True,
                        force=True,
                        specific_tags=[&#34;Manufacturer&#34;],
                    )
                    if ds.Manufacturer is not None and ds.Manufacturer != &#34;&#34;:
                        if manufacturers.__contains__(ds.Manufacturer):
                            temp_map[k] = v
                    if timing:
                        count += 1
                        percentage_done = count / len(filtered_map) * 100
                        if count % 1000 == 0:
                            print(f&#34;{percentage_done}% done&#34;)
            filtered_map = temp_map

        cls._image_paths = []
        cls._labels = {}
        cls._study_paths = []
        study_path_map = {}
        image_id = 0
        count = 0
        for k, v in filtered_map.items():
            img_path = str(v)
            cls._image_paths.append(img_path)
            cls._labels[image_id] = temp_labels[int(k)]
            image_id += 1
            study_path = os.path.dirname(img_path)
            if study_path_map.__contains__(study_path):
                continue
            else:
                study_path_map[study_path] = image_id
                cls._study_paths.append(study_path)
            if timing:
                count += 1
                percentage_complete = count / len(filtered_map) * 100
                if count % 1000 == 0:
                    print(
                        &#34;Now Processing filtered images: &#34;
                        + str(percentage_complete)
                        + &#34;%&#34;
                    )
        cls._init_stats()
        if timing:
            cls.timing(t0, &#34;filter_images&#34;)

    @classmethod
    def reset_data(cls, timing=False):
        &#34;&#34;&#34;Resets the data to the original data&#34;&#34;&#34;
        t0 = time.time()
        cls._filtered_flags = {}
        cls._image_paths = []
        cls._labels = {}
        cls._study_paths = []
        cls._init()
        if timing:
            cls.timing(t0, &#34;reset_data&#34;)

    # --------------------------------------------------------------------------
    @classmethod
    def partition_data(
        cls,
        num_partitions,
        randomized=True,
        save_paths_to_files=True,
        save_directory=None,
        file_name_prefix=None,
        timing=False,
    ):
        &#34;&#34;&#34;Partitions the data into the specified number of partitions.

        Parameters
        ----------
        num_partitions : int
            The number of partitions to split the data into.
        randomized : bool
            If True, the data will be randomized before partitioning.
        save_paths_to_files : bool
            If True, the paths to the images will be saved to a file for each
            partition.
        save_directory : str
            The directory to save the files to. If None, the files will be
            saved to the current directory.
        file_name_prefix : str
            The prefix to use for the file names. If None, the prefix will be
            &#39;partition_&#39;.
        timing : bool
            If True, timing information will be printed.

        Returns
        -------
        A list of lists of image paths for each partition.
        &#34;&#34;&#34;
        t0 = time.time()
        image_paths = cls._image_paths.copy()
        if randomized:
            random.shuffle(image_paths)

        if file_name_prefix is None:
            file_name_prefix = &#34;partition_&#34;
        num_images = len(image_paths)
        num_images_per_partition = int(num_images / num_partitions)
        partitioned_paths = []
        for i in range(num_partitions):
            partitioned_paths.append([])
        for i in range(num_images):
            partition_id = int(i / num_images_per_partition)
            partitioned_paths[partition_id].append(image_paths[i])
        if save_paths_to_files:
            if save_directory is None:
                # get the current directory to save the files to
                save_directory = os.path.dirname(os.path.realpath(__file__))
            print(&#34;Saving partitioned paths to files in: &#34; + save_directory)
            for i in range(num_partitions):
                partition_path = os.path.join(
                    save_directory, file_name_prefix + str(i) + &#34;.txt&#34;
                )
                with open(partition_path, &#34;w&#34;) as f:
                    for path in partitioned_paths[i]:
                        f.write(path + &#34;\n&#34;)
        if timing:
            cls.timing(t0, &#34;partition_data&#34;)
        return partitioned_paths

    # --------------------------------------------------------------------------
    @classmethod
    def random_sample(cls, size, timing=False):
        &#34;&#34;&#34;Randomly samples the data.

        Parameters
        ----------
        size : int
            The number of images to sample.
        timing : bool
            If True, timing information will be printed.

        Returns
        -------
        A list of image paths.
        &#34;&#34;&#34;
        t0 = time.time()
        image_paths = cls._image_paths.copy()
        random.shuffle(image_paths)
        if timing:
            cls.timing(t0, &#34;random_sample&#34;)
        return image_paths[:size]

    # --------------------------------------------------------------------------
    @classmethod
    def set_dicom_tags(cls, tags):
        &#34;&#34;&#34;Sets the tags to be used when reading dicom files with python
        iterators and generators.

        Parameters
        ----------
        tags : list of str
            The tags to be used when reading dicom files with python iterators
            and generators.
        &#34;&#34;&#34;
        cls.dl.dicom_tags = tags

    @staticmethod
    def timing(t0, label: str):
        &#34;&#34;&#34;Prints the time it takes to perform a certain action

        Parameters
        ----------
        t0 : float
            the time when the action was performed
        label : str
            the label of the action
        &#34;&#34;&#34;
        print(
            &#34;{:&lt;25s}{:&lt;10s}{:&gt;10f}{:^5s}&#34;.format(
                label, &#34;...took &#34;, time.time() - t0, &#34; seconds&#34;
            )
        )</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="omama.data.Data"><code class="flex name class">
<span>class <span class="ident">Data</span></span>
<span>(</span><span>data_loader:<a title="omama.loaders.data_loader.DataLoader" href="loaders/data_loader.html#omama.loaders.data_loader.DataLoader">DataLoader</a>, cache:bool=False, load_cache:bool=False, cache_paths:list=None, print_data:bool=False, timing:bool=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Singleton Data class used to represent and explore dicom data</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>total_2d_noncancer</code></strong> :&ensp;<code>int</code></dt>
<dd>total number of 2D dicoms with a label of NonCancer</dd>
<dt><strong><code>total_2d_cancer</code></strong> :&ensp;<code>int</code></dt>
<dd>total number of 2D dicoms with a label of IndexCancer</dd>
<dt><strong><code>total_2d_preindex</code></strong> :&ensp;<code>int</code></dt>
<dd>total number of 3D dicoms with a label of PreIndexCancer</dd>
<dt><strong><code>total_3d_noncancer</code></strong> :&ensp;<code>int</code></dt>
<dd>total number of 3D dicoms with a label of NonCancer</dd>
<dt><strong><code>total_3d_cancer</code></strong> :&ensp;<code>int</code></dt>
<dd>total number of 3D dicoms with a label of IndexCancer</dd>
<dt><strong><code>total_3d_preindex</code></strong> :&ensp;<code>int</code></dt>
<dd>total number of 3D dicoms with a label of PreIndexCancer</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Data:
    &#34;&#34;&#34;Singleton Data class used to represent and explore dicom data

    Attributes
    ----------
    total_2d_noncancer : int
        total number of 2D dicoms with a label of NonCancer
    total_2d_cancer : int
        total number of 2D dicoms with a label of IndexCancer
    total_2d_preindex : int
        total number of 3D dicoms with a label of PreIndexCancer
    total_3d_noncancer : int
        total number of 3D dicoms with a label of NonCancer
    total_3d_cancer : int
        total number of 3D dicoms with a label of IndexCancer
    total_3d_preindex : int
        total number of 3D dicoms with a label of PreIndexCancer
    &#34;&#34;&#34;

    dl = None  # DataLoader object
    # total number of 2D dicoms with a label of NonCancer
    total_2d_noncancer = 0
    # total number of 2D dicoms with a label of IndexCancer
    total_2d_cancer = 0
    # total number of 3D dicoms with a label of PreIndexCancer
    total_2d_preindex = 0
    # total number of 3D dicoms with a label of NonCancer
    total_3d_noncancer = 0
    # total number of 3D dicoms with a label of IndexCancer
    total_3d_cancer = 0
    # total number of 3D dicoms with a label of PreIndexCancer
    total_3d_preindex = 0
    # the sorted images from all studies. This is the list that image_id is
    # derived from
    _image_paths = []
    # the sorted study paths to all studies. This is the list study_id is
    # derived from
    _study_paths = []
    # dictionary of the label mappings
    _label_mapping_dict = {}
    # dictionary of the generated stats about the data contained in the Data
    # instance
    _stats = {}
    # dictionary of all the labels contained in the Data object instance
    _labels = {}
    # dictionary of flags used while fetching filtered data
    _filtered_flags = {}
    # dictionary of sop_uid to cancer labels
    pat_id_to_label_dict = {}

    _caselist_path = None
    _cache = None
    _load_cache = None
    _print_data = None
    instance = None

    def __new__(
        cls,
        data_loader: DataLoader,
        cache: bool = False,
        load_cache: bool = False,
        cache_paths: list = None,
        print_data: bool = False,
        timing: bool = False,
    ):
        &#34;&#34;&#34;Initializes the Data class and prepares the data for exploratory
        jupyter notebook sessions

        Parameters
        ----------
        data_loader : DataLoader
            object used to tell the Data class where to find the data
        cache : bool
            (default False) whether to cache the data
        load_cache : bool
            (default False) whether to load the data from the cache
        print_data : bool
            (default is False)
            prints out the detailed dictionary of information about all the
            studies and the combined data as well
        timing : float
            sets the timers in the initializing methods to true, and prints out
            how long each one took
            (default is False)
        &#34;&#34;&#34;
        t0 = time.time()
        # allow for multiple instances of the Singleton class as long as different
        # data_loader objects are passed in
        if cls.instance is None or cls.dl != data_loader:
            cls.destroy()
            cls.dl = data_loader
            cls.instance = super().__new__(cls)
            if cache_paths is not None:
                cls.dl.cache_paths = cache_paths
            cls._caselist_path = cls.dl.caselist_path
            cls._cache = cache
            cls._load_cache = load_cache
            cls._print_data = print_data
            print(&#34;DataLoader type is: &#34;, type(cls.dl))
            # initialize the data
            cls._init(timing=timing)
        if timing:
            cls.timing(t0, &#34;total __init__&#34;)
        if cls._print_data:
            pprint.pprint(cls._stats)

        return cls.instance

    @classmethod
    def __str__(cls):
        &#34;&#34;&#34;Prints out the class name and the number of studies and images in
        the data
        &#34;&#34;&#34;
        # save the pprint.pprint into a string
        s = pprint.pformat(cls._stats)
        return f&#34;{cls.__name__}({s})&#34;

    @classmethod
    def __len__(cls):
        &#34;&#34;&#34;Returns the length of all the dicoms in the Data object instance

        Returns
        -------
        length of the Data object instance : int
            the length of all the dicoms in the Data object instance
        &#34;&#34;&#34;
        return len(cls._image_paths)

    @classmethod
    def __getitem__(cls, index):
        &#34;&#34;&#34;Returns the dicom at the given index, or a slice of the dicoms if
        a slice is given

        Parameter
        ---------
        index : int
            the index of the dicom to return

        Returns
        -------
        dicom : dicom.dicom.DicomImage
            the dicom at the given index
        &#34;&#34;&#34;
        # if isinstance(subscript, slice):
        #     # do your handling for a slice object:
        #     print(subscript.start, subscript.stop, subscript.step)
        # else:
        #     # Do your handling for a plain index
        #     print(subscript)
        # check if the index is a slice
        # return dicom.filereader.dcmread(cls._image_paths[index])

        if isinstance(index, slice):
            return [dicom.filereader.dcmread(path) for path in cls._image_paths[index]]
        else:
            return dicom.filereader.dcmread(cls._image_paths[index])

    @classmethod
    def __iter__(cls):
        &#34;&#34;&#34;Returns an iterator for the Data object instance

        Returns
        -------
        iterator : iterator
            an iterator for the Data object instance
        &#34;&#34;&#34;
        # use the image path to read the dicom there and return pixel data
        return (
            dicom.filereader.dcmread(path, specific_tags=cls.dl.dicom_tags)
            for path in cls._image_paths
        )

    @classmethod
    def __call__(cls, *args, **kwargs):
        if cls not in cls.instance:
            cls.instance[cls] = cls(*args, **kwargs)
        return cls.instance[cls]

    @classmethod
    def __instancecheck__(cls):
        return cls.instance

    @property
    def image_paths(self):
        return self._image_paths

    @classmethod
    def destroy(cls):
        &#34;&#34;&#34;Destroys the Data object instance&#34;&#34;&#34;
        cls.instance = None
        cls.dl = None
        # reset the class variables
        cls._study_paths = []
        cls._image_paths = []
        cls._map = {}
        cls._stats = {}
        cls._cache = False
        cls._load_cache = False
        cls._print_data = False
        cls._caselist_path = None
        cls._cache_paths = None

    # --------------------------------------------------------------------------
    @classmethod
    def _init(cls, timing=False):
        &#34;&#34;&#34;Initializes the Data object instance with the data contained in the
        data_loader object

        Parameters
        ----------
        timing : bool
            (default is False) if True, the time it takes to initialize the Data
            object instance is printed
        &#34;&#34;&#34;
        t0 = time.time()
        cls._init_study_paths(timing=timing)
        cls._init_image_paths(timing=timing)
        cls._init_map(timing=timing)
        if cls._load_cache and not cls._cache:
            cls._init_cache(timing=timing)
        elif cls._cache and not cls._load_cache:
            cls._generate_label_map(timing=timing)
            cls._cache_labels(timing=timing)
        elif cls._cache and cls._load_cache:
            cls._init_cache(timing=timing)
            cls._cache_labels(timing=timing)
        else:
            cls._generate_label_map(timing=timing)
        cls._init_labels(timing=timing)
        cls._init_stats(timing=timing)

        if timing:
            cls.timing(t0, &#34;total _init&#34;)

    # --------------------------------------------------------------------------
    @classmethod
    def _init_study_paths(cls, timing=False):
        &#34;&#34;&#34;Initializes the study paths of the Data object instance. O(n) time

        Parameters
        ----------
        timing : bool
            (default is False) if True, the time it takes to initialize the
            study paths is printed
        &#34;&#34;&#34;
        t0 = time.time()
        study_list = []
        if cls._caselist_path is None:
            if cls.dl.data_paths is None or len(cls.dl.data_paths) == 0:
                print(&#34;no study files loaded&#34;)
                return
            # load the sorted study from list of paths
            for path in cls.dl.data_paths:  # iterate through each path
                study = sorted(
                    os.listdir(path)
                )  # get list of studies in the path, sorted
                study_list.append(study)  # add the study to the list of studies
            # loop to create the list of study paths
            for i in range(0, len(study_list)):  # iterate through each study
                study_id = 0  # initialize the study id
                for _ in study_list[i]:
                    #  append the root path to each study
                    study_list[i][study_id] = (
                        cls.dl.data_paths[i] + study_list[i][study_id]
                    )
                    study_id = study_id + 1
            cls._study_paths = sorted(
                [item for sublist in study_list for item in sublist]
            )
        else:
            with open(cls._caselist_path, &#34;r&#34;) as f:
                # read each line which is a path
                for path in f:
                    path = path.strip()
                    if path != &#34;&#34;:
                        study_path = os.path.dirname(path)
                        cls._study_paths.append(study_path)
            # remove any duplicates and sort the list
            cls._study_paths = sorted(list(set(cls._study_paths)))
        if timing is True:
            cls.timing(t0, &#34;load_studies&#34;)

    # --------------------------------------------------------------------------
    @classmethod
    def _init_map(cls, timing=False):
        &#34;&#34;&#34;Initializes the map of labels from the csv files, which is used
        to build a sop_uid to label dictionary. O(n) time complexity.

        Parameters
        ----------
        timing : bool
            (default is False) if True, the time it takes to initialize the
            map is printed
        &#34;&#34;&#34;
        t0 = time.time()

        if cls.dl.csv_paths is None or len(cls.dl.csv_paths) == 0:
            print(&#34;no csv files loaded&#34;)
            return
        # go through each csv file and load the map from it
        for path in cls.dl.csv_paths:
            with open(path, &#34;r&#34;) as f:
                lines = f.readlines()
                for line in lines:
                    values = line.split(&#34;,&#34;)
                    study_id = values[0]
                    lat = values[1]
                    label = values[2].strip()
                    cls._label_mapping_dict[study_id + &#34;_&#34; + lat] = label
        if timing is True:
            cls.timing(t0, &#34;csv_to_map&#34;)

    # --------------------------------------------------------------------------
    @classmethod
    def _init_image_paths(cls, timing=False):
        &#34;&#34;&#34;Initializes the image paths of the Data object instance. O(n) where
        n is the number of subdirectories in each study path.

        Parameters
        ----------
        timing : bool
            (default is False) if True, the time it takes to initialize the
            image paths is printed
        &#34;&#34;&#34;
        t0 = time.time()
        if cls._caselist_path is None:
            # use the path to each study and get the list of images
            for current_path in cls.dl.data_paths:
                # walk through each study
                for path, currentDirectory, files in os.walk(current_path):
                    # iterate through each image in the study
                    for file in files:
                        # if it is a 2D or 3D image, add it to the list of images
                        if file.startswith(
                            cls.dl.dicom_2d_substring
                        ) or file.startswith(cls.dl.dicom_3d_substring):
                            cls._image_paths.append(path + &#34;/&#34; + str(file))
                cls._image_paths = sorted(cls._image_paths)
        else:
            # open the caselist file and read each line which is a path and
            # add it to the list of image paths and then sort the list
            with open(cls._caselist_path, &#34;r&#34;) as f:
                for path in f:
                    path = path.strip()
                    if path != &#34;&#34;:
                        cls._image_paths.append(path)
            cls._image_paths = sorted(cls._image_paths)
        if timing is True:
            cls.timing(t0, &#34;load_images&#34;)

    # --------------------------------------------------------------------------
    @classmethod
    def _generate_label_map(cls, timing=False):
        &#34;&#34;&#34;Generates the label map of the Data object instance. O(n) where n
        is the number of images in the Data object instance.

        Parameters
        ----------
        timing : bool
            (default is False) if True, the time it takes to generate the
            label map is printed
        &#34;&#34;&#34;
        t0 = time.time()
        image_id = 0
        for path in cls._image_paths:
            if (
                os.path.basename(path).startswith(cls.dl.dicom_2d_substring)
                or cls.dl.dicom_2d_substring == &#34;&#34;
            ):
                ds = dicom.filereader.dcmread(
                    path,
                    stop_before_pixels=True,
                    specific_tags=[
                        &#34;ImageLaterality&#34;,
                        cls.dl.patient_identifier,
                        cls.dl.cancer_identifier,
                        &#34;StudyInstanceUID&#34;,
                    ],
                )
                image_laterality = ds.get(&#34;ImageLaterality&#34;)
            else:
                ds = dicom.filereader.dcmread(
                    path,
                    stop_before_pixels=True,
                    specific_tags=[
                        &#34;SharedFunctionalGroupsSequence&#34;,
                        cls.dl.patient_identifier,
                        cls.dl.cancer_identifier,
                        &#34;StudyInstanceUID&#34;,
                    ],
                )
                image_laterality = (
                    ds.SharedFunctionalGroupsSequence[0]
                    .FrameAnatomySequence[0]
                    .FrameLaterality
                )
            can_id = ds.get(cls.dl.cancer_identifier)
            # make dictionary of labels based off of ImageID as index
            label = cls._label(can_id, image_laterality)
            pat_id = ds.get(cls.dl.patient_identifier)
            cls.pat_id_to_label_dict[pat_id] = label
            cls._labels[image_id] = label

            image_id += 1
            if timing is True:
                if image_id % 1000 == 0:
                    cls.timing(t0, str(image_id))
        if timing is True:
            cls.timing(t0, &#34;load_labels&#34;)

    # --------------------------------------------------------------------------
    @classmethod
    def _init_labels(cls, timing=False):
        &#34;&#34;&#34;Initializes the labels of the Data object instance. O(n)

        Parameters
        ----------
        timing : bool
            (default is False) if True, the time it takes to initialize the
            labels is printed
        &#34;&#34;&#34;
        t0 = time.time()
        cls.total_2d_cancer = 0
        cls.total_3d_cancer = 0
        cls.total_2d_preindex = 0
        cls.total_3d_preindex = 0
        cls.total_2d_noncancer = 0
        cls.total_3d_noncancer = 0
        # loop over the image_paths and generate the counts of all the possible
        # filtered scenarios
        for i in range(0, len(cls._image_paths)):
            path = cls._image_paths[i]
            label = cls._labels[i]
            if (
                os.path.basename(path).startswith(cls.dl.dicom_2d_substring)
                or cls.dl.dicom_2d_substring == &#34;&#34;
            ):
                if label == &#34;IndexCancer&#34;:
                    cls.total_2d_cancer += 1
                elif label == &#34;PreIndexCancer&#34;:
                    cls.total_2d_preindex += 1
                elif label == &#34;NonCancer&#34;:
                    cls.total_2d_noncancer += 1
            else:
                if label == &#34;IndexCancer&#34;:
                    cls.total_3d_cancer += 1
                elif label == &#34;PreIndexCancer&#34;:
                    cls.total_3d_preindex += 1
                elif label == &#34;NonCancer&#34;:
                    cls.total_3d_noncancer += 1
        if timing is True:
            cls.timing(t0, &#34;generate_counts&#34;)

    # --------------------------------------------------------------------------
    @property
    def labels(cls):
        &#34;&#34;&#34;Returns the labels of the Data object instance&#34;&#34;&#34;
        return cls._labels

    @classmethod
    def _init_stats(cls, timing=False):
        &#34;&#34;&#34;Initializes the statistics of the Data object instance

        Parameters
        ----------
        timing : bool
            (default is False) if True, the time it takes to initialize the
            statistics is printed
        &#34;&#34;&#34;
        t0 = time.time()
        cls._stats = {}
        tot_all_dicoms = 0
        tot_all_2d = 0
        tot_all_3d = 0
        files_2d_per_study = {}
        files_3d_per_study = {}
        # loop over the image_paths and generate the counts of all the possible
        # scenarios
        for path in cls._image_paths:
            for study_folder in cls.dl.study_folder_names:
                if study_folder in path:
                    # counting the 2d Dicom files per study
                    if (
                        os.path.basename(path).startswith(cls.dl.dicom_2d_substring)
                        or cls.dl.dicom_2d_substring == &#34;&#34;
                    ):
                        tot_all_2d += 1
                        files_2d_per_study[study_folder] = (
                            files_2d_per_study.get(study_folder, 0) + 1
                        )
                    #  counting the 3d Dicom files per study
                    elif (
                        os.path.basename(path).startswith(cls.dl.dicom_3d_substring)
                        or cls.dl.dicom_3d_substring == &#34;&#34;
                    ):
                        tot_all_3d += 1
                        files_3d_per_study[study_folder] = (
                            files_3d_per_study.get(study_folder, 0) + 1
                        )
                    tot_all_dicoms += 1
        # Using the counts from above, generate the statistics for each study
        # as well as the global statistics
        for i in range(0, len(cls.dl.data_paths)):
            folder = str(cls.dl.study_folder_names[i])
            if folder in files_2d_per_study:
                _2D = files_2d_per_study[folder]
            else:
                _2D = 0
            if folder in files_3d_per_study:
                _3D = files_3d_per_study[folder]
            else:
                _3D = 0
            total = _2D + _3D
            case = {&#34;total&#34;: total, &#34;3D&#34;: _3D, &#34;2D&#34;: _2D}
            cls._stats[folder] = case
            # using SimpleNamespace to give dot notation access to the stats
            cls._stats[folder] = SimpleNamespace(**cls._stats[folder])
        cls._stats[&#34;total_all_dicoms&#34;] = tot_all_dicoms
        cls._stats[&#34;total_2d_all&#34;] = tot_all_2d
        cls._stats[&#34;total_3d_all&#34;] = tot_all_3d
        cls._stats[&#34;total_2d_cancer&#34;] = cls.total_2d_cancer
        cls._stats[&#34;total_2d_preindex&#34;] = cls.total_2d_preindex
        cls._stats[&#34;total_2d_noncancer&#34;] = cls.total_2d_noncancer
        cls._stats[&#34;total_3d_cancer&#34;] = cls.total_3d_cancer
        cls._stats[&#34;total_3d_preindex&#34;] = cls.total_3d_preindex
        cls._stats[&#34;total_3d_noncancer&#34;] = cls.total_3d_noncancer
        cls._stats[&#34;total_cancer&#34;] = cls.total_2d_cancer + cls.total_3d_cancer
        cls._stats[&#34;total_preindex&#34;] = cls.total_2d_preindex + cls.total_3d_preindex
        cls._stats[&#34;total_noncancer&#34;] = cls.total_2d_noncancer + cls.total_3d_noncancer
        cls._stats[&#34;total_no_label&#34;] = tot_all_dicoms - (
            cls.total_3d_noncancer
            + cls.total_2d_noncancer
            + cls.total_3d_preindex
            + cls.total_2d_preindex
            + cls.total_3d_cancer
            + cls.total_2d_cancer
        )
        # Using SimpleNamespace to give nested dot notation access to the stats
        cls._stats = SimpleNamespace(**cls._stats)
        if timing is True:
            cls.timing(t0, &#34;generate_stats&#34;)

    # --------------------------------------------------------------------------
    @classmethod
    def _save_pickle(cls, path, data, timing=False):
        &#34;&#34;&#34;Saves the data to a pickle file

        Parameters
        ----------
        path : str
            the path and name of the pickle file to save the data to
        data : dict
            the data to save to the pickle file
        timing : bool
            (default is False) if True, the time it takes to save the data is
            printed
        &#34;&#34;&#34;
        t0 = time.time()
        if not os.path.isfile(path):
            with open(path, &#34;wb&#34;) as file:
                pickle.dump(data, file)
            file.close()
        else:
            pickle_file = open(path, &#34;wb&#34;)
            pickle.dump(data, pickle_file)
            pickle_file.close()

        if timing is True:
            cls.timing(t0, &#34;save_pickle&#34;)

    # --------------------------------------------------------------------------
    @classmethod
    def _load_pickle(cls, path, timing=False):
        &#34;&#34;&#34;Loads a pickle file from the given path

        Parameters
        ----------
        path : str
            the path to the pickle file
        timing : bool
            (default is False) if True, the time it takes to load the pickle file
            is printed
        &#34;&#34;&#34;
        t0 = time.time()
        pickle_file = open(path, &#34;rb&#34;)
        result = pickle.load(pickle_file)
        pickle_file.close()
        if timing is True:
            cls.timing(t0, &#34;load_pickle&#34;)
        return result

    # --------------------------------------------------------------------------
    @classmethod
    def _cache_labels(cls, timing=False):
        &#34;&#34;&#34;Caches the _labels and the sopuid_to_labels of the Data object
        instance

        Parameters
        ----------
        timing : bool
            (default is False) if True, the time it takes to cache the labels is
             printed
        &#34;&#34;&#34;
        t0 = time.time()

        cls._save_pickle(cls.dl.cache_paths[0], cls._labels)
        cls._save_pickle(cls.dl.cache_paths[1], cls.pat_id_to_label_dict)

        if timing is True:
            cls.timing(t0, &#34;save_pickle&#34;)

    # --------------------------------------------------------------------------
    @classmethod
    def _init_cache(cls, timing=False):
        &#34;&#34;&#34;Initializes the cache of the Data object instance

        Parameters
        ----------
        timing : bool
            (default is False) if True, the time it takes to initialize the
            cache is printed
        &#34;&#34;&#34;
        t0 = time.time()
        cls._labels = cls._load_pickle(cls.dl.cache_paths[0])
        cls.pat_id_to_label_dict = cls._load_pickle(cls.dl.cache_paths[1])
        if timing is True:
            cls.timing(t0, &#34;load_pickle&#34;)

    # --------------------------------------------------------------------------
    @classmethod
    def path(
        cls,
        image_id: int = None,
        dicom_name: str = None,
        path: str = None,
        study_instance_uid: str = None,
        study_key: int = None,
        timing=False,
    ) -&gt; str:
        &#34;&#34;&#34;Returns the path to the image, given one of the several ids

        Parameters
        ----------
        image_id : int
            (default is None) the id of the image
        dicom_name : str
            (default is None) the name of the dicom file
        path : str
            (default is None) the path of the image
        study_instance_uid : str
            (default is None) the study instance uid of the image
        study_key : int
            (default is None) the key of the study
        timing : bool
            (default is False) if True, the time it takes to find the path is printed

        Returns
        -------
        path : str
            the path of the image
        &#34;&#34;&#34;
        t0 = time.time()
        if image_id is not None:
            path = cls._image_paths[image_id]
        elif dicom_name is not None:
            path = &#34;&#34;.join([s for s in cls._image_paths if dicom_name in s])
        elif path is not None:
            path = path
        elif study_instance_uid is not None:
            file_id = [
                idx for idx, s in enumerate(cls._study_paths) if study_instance_uid in s
            ][0]
            path = cls._study_paths[file_id]
        elif study_key is not None:
            path = cls._study_paths[study_key]
        else:
            return (
                &#34;Error: No valid image_id, dicom_name, path, &#34;
                &#34;study_instance_uid or study_key was specified &#34;
            )
        if timing is True:
            cls.timing(t0, &#34;get_path&#34;)
        return path

    # --------------------------------------------------------------------------
    @classmethod
    def _dicom(
        cls,
        dicom_name: str = None,
        image_id: int = None,
        dicom_path: str = None,
        pixels=False,
        dicom_header=False,
        timing=False,
    ):
        &#34;&#34;&#34;Returns the dicom object of the image with the given path

        Parameters
        ----------
        dicom_name : str
            (default is None) the name of the dicom file
        image_id : int
            (default is None) the id of the image
        dicom_path : str
            (default is None) the path of the dicom file
        pixels : bool
            (default is False) if True, the pixel data of the image is returned
        dicom_header : bool
            (default is False) if True, the dicom header of the image is
            returned
        timing : bool
            (default is False) if True, the time it takes to load the dicom
            is printed

        Returns
        -------
        dicom : pydicom.dicom.Dataset
            the dicom object of the image
        &#34;&#34;&#34;
        t0 = time.time()

        if image_id is not None:
            img_path = cls.path(image_id=image_id)
            if cls._validate_path(img_path) is False:
                return &#34;path not valid&#34;, None
        elif dicom_path is not None:
            if cls._validate_path(dicom_path) is False:
                return &#34;path not valid&#34;, None
            img_path = dicom_path
        elif dicom_name is not None:
            img_path = cls.path(dicom_name=dicom_name)
            if cls._validate_path(img_path) is False:
                return &#34;path not valid&#34;, None
        else:
            print(
                &#34;Error: No valid dicom_name, image_id, dicom_path or &#34;
                &#34;dicom_name was specified&#34;
            )
            return &#34;None&#34;, None
        if dicom_header and pixels:
            ds = dicom.filereader.dcmread(img_path, force=True)
        elif pixels:
            ds = dicom.filereader.dcmread(
                img_path, force=True, specific_tags=cls.dl.dicom_tags
            )
        else:
            ds = dicom.filereader.dcmread(img_path, force=True, stop_before_pixels=True)
        if timing is True:
            cls.timing(t0, &#34;_get_dicom&#34;)
        return ds

    # --------------------------------------------------------------------------
    @classmethod
    def _validate_path(
        cls,
        path,
        _2d=True,
        _3d=True,
    ) -&gt; bool:
        &#34;&#34;&#34;Checks if the path is valid

        Parameters
        ----------
        path : str
            the path to check
        _2d : bool
            (default is True) if True, the path must be a 2D image
        _3d : bool
            (default is True) if True, the path must be a 3D image

        Returns
        -------
        valid : bool
            if True, the path is valid and can be used, otherwise it is not
        &#34;&#34;&#34;
        if _2d and _3d:
            if (
                os.path.basename(path).startswith(cls.dl.dicom_3d_substring)
                or os.path.basename(path).startswith(cls.dl.dicom_2d_substring)
                or cls.dl.dicom_3d_substring == &#34;&#34;
                or cls.dl.dicom_2d_substring == &#34;&#34;
            ):
                return True
        elif _2d:
            if (
                os.path.basename(path).startswith(cls.dl.dicom_2d_substring)
                or cls.dl.dicom_2d_substring == &#34;&#34;
            ):
                return True
        elif _3d:
            if (
                os.path.basename(path).startswith(cls.dl.dicom_3d_substring)
                or cls.dl.dicom_3d_substring == &#34;&#34;
            ):
                return True
        return False

    # --------------------------------------------------------------------------
    @classmethod
    def _files_in_series(
        cls,
        path=None,
        study_instance_uid=None,
        _2d=True,
        _3d=True,
        labels=None,
        manufacturer=None,
        timing=False,
    ) -&gt; list:
        &#34;&#34;&#34;Returns the files in the series with the given path

        Parameters
        ----------
        path : str,
            (default is None) the path of the series
        study_instance_uid : str
            (default is None) the study instance uid of the series
        timing : bool
            (default is False) if True, the time it takes to load the dicom
            is printed

        Returns
        -------
        files : list
            the files in the series
        &#34;&#34;&#34;
        t0 = time.time()
        if path is not None:
            file_names = os.listdir(path)
        else:
            idx = [
                idx for idx, s in enumerate(cls._study_paths) if study_instance_uid in s
            ][0]
            file_names = os.listdir(cls._study_paths[idx])
        file_names = [f for f in file_names if cls._validate_path(f, _2d, _3d)]
        if labels is not None:
            temp = []
            for f in file_names:
                img_idx = cls._image_id(dicom_name=f, timing=timing)
                if img_idx != -1:
                    temp.append(f)
            file_names = temp.copy()
        if manufacturer is not None:
            temp = []
            for f in file_names:
                ds = cls._dicom(
                    dicom_name=f, pixels=False, dicom_header=False, timing=timing
                )
                if ds.Manufacturer == manufacturer:
                    temp.append(f)
            file_names = temp.copy()
        if timing is True:
            cls.timing(t0, &#34;get_file_names_in_series&#34;)
        return file_names

    # --------------------------------------------------------------------------
    @classmethod
    def _image_id(cls, dicom_name, timing=False) -&gt; int:
        &#34;&#34;&#34;Returns the image id of the image with the given dicom name

        Parameters
        ----------
        dicom_name : str
            the dicom name of the image
        timing : bool
            (default is False) if True, the time it takes to load the dicom
            is printed

        Returns
        -------
        image_id : int
            the image id of the image
        &#34;&#34;&#34;
        t0 = time.time()
        index = -1
        temp_index = 0
        for img in cls._image_paths:
            if dicom_name in img:
                index = temp_index
                break
            temp_index += 1
        if timing is True:
            cls.timing(t0, &#34;image_id&#34;)
        return index

    # --------------------------------------------------------------------------
    @classmethod
    def _study_key(cls, study_instance_uid, timing=False) -&gt; int:
        &#34;&#34;&#34;Returns the study key of the study with the given study instance uid

        Parameters
        ----------
        study_instance_uid : str
            the study instance uid of the study
        timing : bool
            (default is False) if True, the time it takes to load the dicom
            is printed

        Returns
        -------
        study_key : int
            the study key of the study
        &#34;&#34;&#34;
        t0 = time.time()
        index = [
            idx for idx, s in enumerate(cls._study_paths) if study_instance_uid in s
        ][0]
        if timing is True:
            cls.timing(t0, &#34;study_key&#34;)
        return index

    # --------------------------------------------------------------------------
    @classmethod
    def _label(cls, cancer_id, image_laterality, timing=False) -&gt; str:
        &#34;&#34;&#34;Returns the label of the image with the given study instance uid and
         image laterality

        Parameters
        ----------
        cancer_id : str
            the study instance uid of the study
        image_laterality : str
            the image laterality of the image
        timing : bool
            (default is False) if True, the time it takes to load the dicom
            is printed

        Returns
        -------
        label : str
            the label of the image
        &#34;&#34;&#34;
        t0 = time.time()
        key = str(cancer_id) + &#34;_&#34; + str(image_laterality)
        if key in cls._label_mapping_dict:
            label = cls._label_mapping_dict[key]
        elif str(cancer_id) + &#34;_&#34; + &#34;None&#34; in cls._label_mapping_dict:
            label = cls._label_mapping_dict[str(cancer_id) + &#34;_&#34; + &#34;None&#34;]
        elif (
            (str(cancer_id) + &#34;_&#34; + &#34;L&#34; in cls._label_mapping_dict)
            or (str(cancer_id) + &#34;_&#34; + &#34;R&#34; in cls._label_mapping_dict)
            or (str(cancer_id) + &#34;_&#34; + &#34;B&#34; in cls._label_mapping_dict)
        ):
            label = &#34;NonCancer&#34;
        else:
            label = &#34;No Label Information&#34;

        if timing is True:
            cls.timing(t0, &#34;get_label&#34;)
        return label

    # --------------------------------------------------------------------------
    @classmethod
    def to_text_file(cls, file_path=None, file_name=None):
        &#34;&#34;&#34;Writes each path from the image_paths list to a text file each
        separated by a new line

        Parameters
        ----------
        file_name : str
            the name of the file to write to
        file_path : str
            the path to the file to write to

        Returns
        -------
        file_path : str
            the path to the file that was written to
        &#34;&#34;&#34;
        if file_path is None:
            # get current working directory
            file_path = os.getcwd() + &#34;/&#34;
        if file_name is None:
            file_name = &#34;image_paths.txt&#34;
        with open(file_path + file_name, &#34;w&#34;) as f:
            for path in cls._image_paths:
                # check if it is the last line in the file and if it is, don&#39;t
                # add a new line
                if path != cls._image_paths[-1]:
                    f.write(path + &#34;\n&#34;)
                else:
                    f.write(path)
        return file_path + file_name

    # --------------------------------------------------------------------------
    @classmethod
    def get_label(cls, cancer_id, timing=False):
        &#34;&#34;&#34;Returns the label of the image with the given sop uid

        Parameters
        ----------
        cancer_id : str
            the sop uid of the image
        timing : bool
            (default is False) if True, the time it takes to load the dicom
            is printed

        Returns
        -------
        label : str
            the label of the image
        &#34;&#34;&#34;
        t0 = time.time()
        if cancer_id in cls.pat_id_to_label_dict:
            label = cls.pat_id_to_label_dict[cancer_id]
        else:
            label = &#34;No Label Information&#34;
        if timing is True:
            cls.timing(t0, &#34;get_label&#34;)
        return label

    # --------------------------------------------------------------------------
    @classmethod
    def get_study(
        cls,
        study_instance_uid: str = None,
        study_key: int = None,
        verbose=False,
        timing=False,
    ) -&gt; SimpleNamespace:
        &#34;&#34;&#34;Returns the study with the given study instance uid or study key

        Parameters
        ----------
        study_instance_uid : str
            (default is None, this or the ID need to be set)
            Uses the StudyInstanceUID to locate the study information and returns
            data as dictionary
        study_key : int
            (default is None, this or the study_instance_uid needs to be set)
            Uses the location of a study which is based off of its index in the
            sorted list of all studies
        verbose : bool
            (default is False) If True, will include additional information
            about the study such as the number of 2D and 3D dicoms in study
        timing : bool
            (default is False) Sets timing flag, if true will time execution time
             of method, else will not

        Returns
        ------
        study : SimpleNamespace
            {&#39;directory&#39;: XX, &#39;images&#39;: [imagefile1, imagefile2, ...]}
            iff (verbose==True) =&gt; info&#39;: {&#39;3D_count&#39;: XX, &#39;2D_count&#39;: XX ..and others}
        &#34;&#34;&#34;
        _2d = True
        _3d = True
        lab = []
        t0 = time.time()
        if study_instance_uid is not None:
            uid_path = cls.path(study_instance_uid=study_instance_uid, timing=timing)
            file_id = cls._study_key(uid_path, timing=timing)
        elif study_key is not None:
            uid_path = cls.path(study_key=study_key, timing=timing)
            study_instance_uid = os.path.basename(uid_path)
            file_id = study_key
        else:
            raise ValueError(&#34;Either study_instance_uid or study_key must be set&#34;)
        if cls._filtered_flags != {}:  # if there are filters
            _2d = cls._filtered_flags[&#34;2D&#34;]
            _3d = cls._filtered_flags[&#34;3D&#34;]
            lab = cls._filtered_flags[&#34;labels&#34;]
            man = cls._filtered_flags[&#34;manufacturers&#34;]
        image_files = cls._files_in_series(
            path=uid_path, _2d=_2d, _3d=_3d, labels=lab, timing=timing
        )
        if cls.dl.dicom_3d_substring != &#34;&#34;:
            files_3d = [i for i in image_files if cls.dl.dicom_3d_substring in i]
        else:
            # if there is no 3d substring, then all files are 3d
            files_3d = [image_files for i in image_files]
        if cls.dl.dicom_2d_substring != &#34;&#34;:
            files_2d = [i for i in image_files if cls.dl.dicom_2d_substring in i]
        else:
            # if there is no 2d substring, then all files are 2d
            files_2d = [image_files for i in image_files]
        # get a list of image ids from each of the files
        image_ids = [cls._image_id(i) for i in image_files]
        # remove all image_ids tha are -1
        image_ids = [i for i in image_ids if i != -1]
        # use the images ids to get the image labels
        image_labels = [cls._labels[i] for i in image_ids]
        # count each of the types in the image labels
        label_counts = Counter(image_labels)

        if verbose:
            info = {
                &#34;total&#34;: len(files_3d) + len(files_2d),
                &#34;3D count&#34;: len(files_3d),
                &#34;2D count&#34;: len(files_2d),
                &#34;label counts&#34;: label_counts,
            }
        else:
            info = None

        study = {
            &#34;directory&#34;: uid_path,
            &#34;study_uid&#34;: study_instance_uid,
            &#34;study_key&#34;: file_id,
            &#34;images&#34;: image_files,
            &#34;info&#34;: info,
        }
        dot_dictionary = SimpleNamespace(**study)
        if timing is True:
            cls.timing(t0, &#34;get_study&#34;)
        return dot_dictionary

    # --------------------------------------------------------------------------
    @classmethod
    def get_image(
        cls,
        image_id=None,
        dicom_name=None,
        path=None,
        pixels=True,
        dicom_header=False,
        timing=False,
    ) -&gt; SimpleNamespace:
        &#34;&#34;&#34;Returns the image with the given image id or dicom name or path

        Parameters
        ----------
        image_id : int
            (default is None, this or the Dicom_ID or path need to be set)
            Uses the image_id to fetch Dicom and returns the specified data
        dicom_name : str
            (default is None, this or the image_id or path need to be set)
            Uses the dicom_name to fetch Dicom, and returns the specified  data
        path : str
            (default is None, this or the image_id or dicom_name need to be set)
            Uses the path to fetch Dicom, and returns the specified data
        pixels : bool
            (default is True) If True will return the pixel array of Dicom,
            else will return None
        dicom_header : bool
            (default is False) If True will return the dicom header as a
            dictionary, else will return None
        timing : bool
            (default is False)
            If true will time execution of method, else will not

        Returns
        ------
        image : SimpleNamespace
            [np.array just the pixels or None if pixels=False, info]
            info is dictionary:
            {&#39;label&#39;: LABELS.Cancer, &#39;filepath&#39;:... &#39;shape&#39;...}
        &#34;&#34;&#34;
        t0 = time.time()
        ds = cls._dicom(
            dicom_name=dicom_name,
            image_id=image_id,
            dicom_path=path,
            pixels=pixels,
            dicom_header=dicom_header,
            timing=timing,
        )
        img = None
        study_instance_uid = None
        img_path = cls.path(image_id=image_id, dicom_name=dicom_name, path=path)
        if os.path.basename(img_path).startswith(cls.dl.dicom_3d_substring):
            ds1 = dicom.filereader.dcmread(
                img_path,
                stop_before_pixels=True,
                specific_tags=[
                    &#34;PatientID&#34;,
                    &#34;InstanceNumber&#34;,
                    &#34;SharedFunctionalGroupsSequence&#34;,
                    &#34;StudyInstanceUID&#34;,
                ],
            )
            study_instance_uid = ds1.StudyInstanceUID
            image_laterality = (
                ds1.SharedFunctionalGroupsSequence[0]
                .FrameAnatomySequence[0]
                .FrameLaterality
            )
            image_shape = (int(ds.NumberOfFrames), int(ds.Rows), int(ds.Columns))
        else:
            ds1 = dicom.filereader.dcmread(
                img_path,
                stop_before_pixels=True,
                specific_tags=[
                    &#34;PatientID&#34;,
                    &#34;InstanceNumber&#34;,
                    &#34;ImageLaterality&#34;,
                    &#34;StudyInstanceUID&#34;,
                ],
            )
            study_instance_uid = ds1.StudyInstanceUID
            image_laterality = ds1.get(&#34;ImageLaterality&#34;)
            image_shape = (int(ds.Rows), int(ds.Columns))

        # img_index = cls._image_id(os.path.basename(img_path))
        # label = cls._labels[int(img_index)]

        # get the dicom name
        sop_uid = os.path.basename(img_path)
        if cls.dl.dicom_3d_substring != &#34;&#34; and cls.dl.dicom_2d_substring != &#34;&#34;:
            # remove the dicom_3d_substring or dicom_2d_substring from the beginning
            sop_uid = sop_uid.replace(cls.dl.dicom_3d_substring + &#34;.&#34;, &#34;&#34;)
            sop_uid = sop_uid.replace(cls.dl.dicom_2d_substring + &#34;.&#34;, &#34;&#34;)

        # get the image label
        label = cls.get_label(sop_uid)

        if pixels is True:
            img = ds.pixel_array
        if dicom_header is False:
            ds = None
        dictionary = {
            &#34;filePath&#34;: img_path,
            &#34;SOPInstanceUID&#34;: sop_uid,
            &#34;StudyInstanceUID&#34;: study_instance_uid,
            &#34;PatientID&#34;: ds1.PatientID,
            &#34;InstanceNumber&#34;: ds1.InstanceNumber,
            &#34;label&#34;: label,
            &#34;imageLaterality&#34;: image_laterality,
            &#34;shape&#34;: image_shape,
            &#34;metadata&#34;: ds,
            &#34;pixels&#34;: img,
        }
        dot_dictionary = SimpleNamespace(**dictionary)
        if timing:
            cls.timing(t0, &#34;get_image&#34;)
        return dot_dictionary

    # --------------------------------------------------------------------------
    @classmethod
    def next_image(
        cls, _2d=False, _3d=False, label=None, randomize=False, timing=False
    ) -&gt; Generator[SimpleNamespace, None, None]:
        &#34;&#34;&#34;Generator to filter and return iteratively all the filtered images in
        the dataset

        Parameters
        ----------
        _2d : bool
           (default is False, this or _3D or both needs to be set to True)
           Filter flag used to add 2D images to returned set of Dicoms
        _3d : bool
           (default is False, this or _2D or both needs to be set to True)
           Filter flag used to add 3D images to returned set of Dicoms
        label : str
           (default is None which is all labeled images)
           options are IndexCancer, NonCancer, PreIndexCancer
        randomize : bool
           (default is False) If True will randomize the order of the
           returned images
        timing : bool
           (default is False) If true will time execution of method,
           else will not

        Returns
        -------
        image : generator
           [np.array just the pixels, info]
           info is dictionary: {&#39;label&#39;: LABELS.Cancer, &#39;filepath&#39;:... &#39;shape&#39;...}

        &#34;&#34;&#34;
        t0 = time.time()
        generator_map = {}
        image_index_list = {}
        if label is not None:
            for i in range(len(cls._labels)):
                if cls._labels[i] == label:
                    image_index_list[i] = cls._image_paths[i]
        else:
            for i in range(len(cls._labels)):
                image_index_list[i] = cls._image_paths[i]

        if _2d and _3d:
            for k, v in image_index_list.items():
                generator_map[k] = v
        elif _2d:
            for k, v in image_index_list.items():
                if os.path.basename(v).startswith(cls.dl.dicom_2d_substring):
                    generator_map[k] = v
                elif cls.dl.dicom_2d_substring == &#34;&#34;:
                    generator_map[k] = v
        else:
            for k, v in image_index_list.items():
                if os.path.basename(v).startswith(cls.dl.dicom_3d_substring):
                    generator_map[k] = v

        # shuffle the generator
        dicoms = list(generator_map.items())
        if randomize is True:
            random.shuffle(dicoms)

        for k, v in dicoms:
            img_path = str(v)
            test_label = cls._labels[int(k)]
            if test_label == label or label is None:
                ds = cls.get_image(path=img_path)
                try:
                    yield ds
                except StopIteration:
                    break
            else:
                continue
        if timing:
            cls.timing(t0, &#34;next_image_all&#34;)

    # --------------------------------------------------------------------------
    @classmethod
    def filter_data(
        cls,
        _2d=True,
        _3d=True,
        shapes: list = None,
        row_max: int = None,
        row_min: int = None,
        col_max: int = None,
        col_min: int = None,
        frames_max: int = None,
        frames_min: int = None,
        age_range: list = None,
        labels: list = None,
        studies: list = None,
        manufacturers: list = None,
        timing=False,
    ):
        &#34;&#34;&#34;Filters the dataset to include only Dicoms that match the specified
        filter flags. Configures internal class data in a way that all the Data
        methods work the same, but only will be on the filtered data.
        To reset the filtered data to the original dataset, use the
        reset_data method.

        Parameters
        ----------
        _2d : int
            (default is True, includes 2D images)
            Filter flag used to remove 2D images
        _3d : str
            (default is True, includes 3D images)
            Filter flag used to remove 3D images
        shapes: list[&#39;(X1,Y1)&#39;, &#39;(X2,Y2)&#39;, ..., (Xn,Yn,Zn)&#39;]
            (default is None, includes all shapes)
            specify the shapes of the images to include
        row_max: int
            (default is None, includes all rows)
            Filter flag used to remove images with rows greater than the
            specified value
        row_min: int
            (default is None, includes all rows)
            Filter flag used to remove images with rows less than the
            specified value
        col_max: int
            (default is None, includes all columns)
            Filter flag used to remove images with columns greater than the
            specified value
        col_min: int
            (default is None, includes all columns)
            Filter flag used to remove images with columns less than the
            specified value
        frames_max: int
            (default is None, includes all frames)
            Filter flag used to remove images with frames greater than the
            specified value
        frames_min: int
            (default is None, includes all frames)
            Filter flag used to remove images with frames less than the
            specified value
        age_range: list[min, max]
            (Default is None, include all ages)
            specify the age range in years to filter images by age
        labels: list
            (default is None, includes all labels)
            specify the labels of the images to include
        studies: list
            (default is None, includes all studies)
            specify the studies of the images to include
        manufacturers: list
            (default is None, includes all manufacturers)
            specify the manufacturers of the images to include
        timing: bool
            (default is False) If true will time execution of method,
            else will not
        &#34;&#34;&#34;
        t0 = time.time()
        # build the filtered_flags dictionary
        cls._filtered_flags = {
            &#34;2D&#34;: _2d,
            &#34;3D&#34;: _3d,
            &#34;shapes&#34;: shapes,
            &#34;row_max&#34;: row_max,
            &#34;row_min&#34;: row_min,
            &#34;col_max&#34;: col_max,
            &#34;col_min&#34;: col_min,
            &#34;frames_max&#34;: frames_max,
            &#34;frames_min&#34;: frames_min,
            &#34;age_range&#34;: age_range,
            &#34;labels&#34;: labels,
            &#34;studies&#34;: studies,
            &#34;manufacturers&#34;: manufacturers,
        }
        label_to_path_map = {}
        dimension_map = {}
        filtered_map = {}
        temp_labels = {}
        # remove the labels that are not in the filtered_flags first
        if labels is not None:
            for label in labels:
                for i in range(len(cls._labels)):
                    if cls._labels[i] == label:
                        temp_labels[i] = cls._labels[i]
                        label_to_path_map[i] = cls._image_paths[i]
        else:
            for i in range(len(cls._labels)):
                temp_labels[i] = cls._labels[i]
                label_to_path_map[i] = cls._image_paths[i]
        # remove the dimensions that are not in the filtered_flags
        if _2d and _3d:
            for k, v in label_to_path_map.items():
                if studies is not None:
                    for study in studies:
                        if study in v:
                            dimension_map[k] = v
                else:
                    dimension_map[k] = v
        elif _2d:
            for k, v in label_to_path_map.items():
                if (
                    os.path.basename(v).startswith(cls.dl.dicom_2d_substring)
                    or cls.dl.dicom_2d_substring == &#34;&#34;
                ):
                    if studies is not None:
                        for study in studies:
                            if study in v:
                                dimension_map[k] = v
                    else:
                        dimension_map[k] = v
        else:
            for k, v in label_to_path_map.items():
                if (
                    os.path.basename(v).startswith(cls.dl.dicom_3d_substring)
                    or cls.dl.dicom_3d_substring == &#34;&#34;
                ):
                    if studies is not None:
                        for study in studies:
                            if study in v:
                                dimension_map[k] = v
                    else:
                        dimension_map[k] = v
        # next filter by the shapes of the images
        if shapes is not None:
            pattern = &#34;&#34;
            for shape in shapes:
                print(f&#34;Filtering for shape: {shape}&#34;)
                if shape != shapes[-1]:
                    pattern += shape + &#34;|&#34;
                else:
                    pattern += shape
            count = 0
            for k, v in dimension_map.items():
                img_path = str(v)
                test_label = cls._labels[int(k)]
                if labels is None or labels.__contains__(test_label):
                    ds = dicom.filereader.dcmread(
                        img_path,
                        stop_before_pixels=True,
                        force=True,
                        specific_tags=[&#34;Columns&#34;, &#34;Rows&#34;, &#34;NumberOfFrames&#34;],
                    )
                    rows = ds.Rows
                    cols = ds.Columns
                    if os.path.basename(img_path).startswith(cls.dl.dicom_3d_substring):
                        frames = ds.NumberOfFrames
                        shape = str(
                            &#34;(&#34; + str(rows) + &#34;,&#34; + str(cols) + &#34;,&#34; + str(frames) + &#34;)&#34;
                        )
                    else:
                        shape = str(&#34;(&#34; + str(rows) + &#34;,&#34; + str(cols) + &#34;)&#34;)
                    if re.search(pattern, shape) is not None:
                        filtered_map[k] = v
                    if timing:
                        count += 1
                        if count % 100 == 0:
                            percentage_done = int(count / len(dimension_map) * 100)
                            print(f&#34;{percentage_done}% done&#34;)

        elif (
            shapes is None
            and (col_max is not None and row_max is not None)
            or (col_min is not None and row_min is not None)
        ):
            count = 0
            for k, v in dimension_map.items():
                img_path = str(v)
                test_label = cls._labels[int(k)]
                if labels is None or labels.__contains__(test_label):
                    ds = dicom.filereader.dcmread(
                        img_path,
                        stop_before_pixels=True,
                        force=True,
                        specific_tags=[&#34;Columns&#34;, &#34;Rows&#34;, &#34;NumberOfFrames&#34;],
                    )
                    rows = ds.Rows
                    cols = ds.Columns
                    frames = 1
                    if os.path.basename(img_path).startswith(cls.dl.dicom_3d_substring):
                        frames = ds.NumberOfFrames
                    if (
                        (col_min is None or col_min &lt;= cols)
                        and (col_max is None or cols &lt;= col_max)
                        and (row_min is None or row_min &lt;= rows)
                        and (row_max is None or rows &lt;= row_max)
                        and (frames_min is None or frames_min &lt;= frames)
                        and (frames_max is None or frames &lt;= frames_max)
                    ):
                        filtered_map[k] = v
                    if timing:
                        count += 1
                        percentage_done = count / len(dimension_map) * 100
                        if count % 1000 == 0:
                            print(f&#34;{percentage_done}% done&#34;)
        else:
            filtered_map = dimension_map

        # filter by the age range
        temp_map = {}
        count = 0
        if age_range is not None:
            # turning years into months to match how age is stored in dicom
            age_range[0] = int(age_range[0] * 12)
            age_range[1] = int(age_range[1] * 12)
            for k, v in filtered_map.items():
                img_path = str(v)
                test_label = cls._labels[int(k)]
                if labels is None or labels.__contains__(test_label):
                    ds = dicom.filereader.dcmread(
                        img_path,
                        stop_before_pixels=True,
                        force=True,
                        specific_tags=[&#34;PatientAge&#34;, &#34;PatientSex&#34;],
                    )
                    if ds.PatientAge is not None and ds.PatientAge != &#34;&#34;:
                        age = int(ds.PatientAge[:-1])
                        if age_range[0] &lt;= age &lt;= age_range[1]:
                            temp_map[k] = v
                    if timing:
                        count += 1
                        percentage_done = count / len(filtered_map) * 100
                        if count % 1000 == 0:
                            print(f&#34;{percentage_done}% done&#34;)
            filtered_map = temp_map

        # filter by manufacturer
        temp_map = {}
        count = 0
        if manufacturers is not None:
            for k, v in filtered_map.items():
                img_path = str(v)
                test_label = cls._labels[int(k)]
                if labels is None or labels.__contains__(test_label):
                    ds = dicom.filereader.dcmread(
                        img_path,
                        stop_before_pixels=True,
                        force=True,
                        specific_tags=[&#34;Manufacturer&#34;],
                    )
                    if ds.Manufacturer is not None and ds.Manufacturer != &#34;&#34;:
                        if manufacturers.__contains__(ds.Manufacturer):
                            temp_map[k] = v
                    if timing:
                        count += 1
                        percentage_done = count / len(filtered_map) * 100
                        if count % 1000 == 0:
                            print(f&#34;{percentage_done}% done&#34;)
            filtered_map = temp_map

        cls._image_paths = []
        cls._labels = {}
        cls._study_paths = []
        study_path_map = {}
        image_id = 0
        count = 0
        for k, v in filtered_map.items():
            img_path = str(v)
            cls._image_paths.append(img_path)
            cls._labels[image_id] = temp_labels[int(k)]
            image_id += 1
            study_path = os.path.dirname(img_path)
            if study_path_map.__contains__(study_path):
                continue
            else:
                study_path_map[study_path] = image_id
                cls._study_paths.append(study_path)
            if timing:
                count += 1
                percentage_complete = count / len(filtered_map) * 100
                if count % 1000 == 0:
                    print(
                        &#34;Now Processing filtered images: &#34;
                        + str(percentage_complete)
                        + &#34;%&#34;
                    )
        cls._init_stats()
        if timing:
            cls.timing(t0, &#34;filter_images&#34;)

    @classmethod
    def reset_data(cls, timing=False):
        &#34;&#34;&#34;Resets the data to the original data&#34;&#34;&#34;
        t0 = time.time()
        cls._filtered_flags = {}
        cls._image_paths = []
        cls._labels = {}
        cls._study_paths = []
        cls._init()
        if timing:
            cls.timing(t0, &#34;reset_data&#34;)

    # --------------------------------------------------------------------------
    @classmethod
    def partition_data(
        cls,
        num_partitions,
        randomized=True,
        save_paths_to_files=True,
        save_directory=None,
        file_name_prefix=None,
        timing=False,
    ):
        &#34;&#34;&#34;Partitions the data into the specified number of partitions.

        Parameters
        ----------
        num_partitions : int
            The number of partitions to split the data into.
        randomized : bool
            If True, the data will be randomized before partitioning.
        save_paths_to_files : bool
            If True, the paths to the images will be saved to a file for each
            partition.
        save_directory : str
            The directory to save the files to. If None, the files will be
            saved to the current directory.
        file_name_prefix : str
            The prefix to use for the file names. If None, the prefix will be
            &#39;partition_&#39;.
        timing : bool
            If True, timing information will be printed.

        Returns
        -------
        A list of lists of image paths for each partition.
        &#34;&#34;&#34;
        t0 = time.time()
        image_paths = cls._image_paths.copy()
        if randomized:
            random.shuffle(image_paths)

        if file_name_prefix is None:
            file_name_prefix = &#34;partition_&#34;
        num_images = len(image_paths)
        num_images_per_partition = int(num_images / num_partitions)
        partitioned_paths = []
        for i in range(num_partitions):
            partitioned_paths.append([])
        for i in range(num_images):
            partition_id = int(i / num_images_per_partition)
            partitioned_paths[partition_id].append(image_paths[i])
        if save_paths_to_files:
            if save_directory is None:
                # get the current directory to save the files to
                save_directory = os.path.dirname(os.path.realpath(__file__))
            print(&#34;Saving partitioned paths to files in: &#34; + save_directory)
            for i in range(num_partitions):
                partition_path = os.path.join(
                    save_directory, file_name_prefix + str(i) + &#34;.txt&#34;
                )
                with open(partition_path, &#34;w&#34;) as f:
                    for path in partitioned_paths[i]:
                        f.write(path + &#34;\n&#34;)
        if timing:
            cls.timing(t0, &#34;partition_data&#34;)
        return partitioned_paths

    # --------------------------------------------------------------------------
    @classmethod
    def random_sample(cls, size, timing=False):
        &#34;&#34;&#34;Randomly samples the data.

        Parameters
        ----------
        size : int
            The number of images to sample.
        timing : bool
            If True, timing information will be printed.

        Returns
        -------
        A list of image paths.
        &#34;&#34;&#34;
        t0 = time.time()
        image_paths = cls._image_paths.copy()
        random.shuffle(image_paths)
        if timing:
            cls.timing(t0, &#34;random_sample&#34;)
        return image_paths[:size]

    # --------------------------------------------------------------------------
    @classmethod
    def set_dicom_tags(cls, tags):
        &#34;&#34;&#34;Sets the tags to be used when reading dicom files with python
        iterators and generators.

        Parameters
        ----------
        tags : list of str
            The tags to be used when reading dicom files with python iterators
            and generators.
        &#34;&#34;&#34;
        cls.dl.dicom_tags = tags

    @staticmethod
    def timing(t0, label: str):
        &#34;&#34;&#34;Prints the time it takes to perform a certain action

        Parameters
        ----------
        t0 : float
            the time when the action was performed
        label : str
            the label of the action
        &#34;&#34;&#34;
        print(
            &#34;{:&lt;25s}{:&lt;10s}{:&gt;10f}{:^5s}&#34;.format(
                label, &#34;...took &#34;, time.time() - t0, &#34; seconds&#34;
            )
        )</code></pre>
</details>
<h3>Class variables</h3>
<dl>
<dt id="omama.data.Data.dl"><code class="name">var <span class="ident">dl</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="omama.data.Data.instance"><code class="name">var <span class="ident">instance</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="omama.data.Data.pat_id_to_label_dict"><code class="name">var <span class="ident">pat_id_to_label_dict</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="omama.data.Data.total_2d_cancer"><code class="name">var <span class="ident">total_2d_cancer</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="omama.data.Data.total_2d_noncancer"><code class="name">var <span class="ident">total_2d_noncancer</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="omama.data.Data.total_2d_preindex"><code class="name">var <span class="ident">total_2d_preindex</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="omama.data.Data.total_3d_cancer"><code class="name">var <span class="ident">total_3d_cancer</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="omama.data.Data.total_3d_noncancer"><code class="name">var <span class="ident">total_3d_noncancer</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="omama.data.Data.total_3d_preindex"><code class="name">var <span class="ident">total_3d_preindex</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="omama.data.Data.destroy"><code class="name flex">
<span>def <span class="ident">destroy</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><p>Destroys the Data object instance</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def destroy(cls):
    &#34;&#34;&#34;Destroys the Data object instance&#34;&#34;&#34;
    cls.instance = None
    cls.dl = None
    # reset the class variables
    cls._study_paths = []
    cls._image_paths = []
    cls._map = {}
    cls._stats = {}
    cls._cache = False
    cls._load_cache = False
    cls._print_data = False
    cls._caselist_path = None
    cls._cache_paths = None</code></pre>
</details>
</dd>
<dt id="omama.data.Data.filter_data"><code class="name flex">
<span>def <span class="ident">filter_data</span></span>(<span>shapes:list=None, row_max:int=None, row_min:int=None, col_max:int=None, col_min:int=None, frames_max:int=None, frames_min:int=None, age_range:list=None, labels:list=None, studies:list=None, manufacturers:list=None, timing=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Filters the dataset to include only Dicoms that match the specified
filter flags. Configures internal class data in a way that all the Data
methods work the same, but only will be on the filtered data.
To reset the filtered data to the original dataset, use the
reset_data method.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>_2d</code></strong> :&ensp;<code>int</code></dt>
<dd>(default is True, includes 2D images)
Filter flag used to remove 2D images</dd>
<dt><strong><code>_3d</code></strong> :&ensp;<code>str</code></dt>
<dd>(default is True, includes 3D images)
Filter flag used to remove 3D images</dd>
<dt><strong><code>shapes</code></strong> :&ensp;<code>list['(X1,Y1)', '(X2,Y2)', ..., (Xn,Yn,Zn)']</code></dt>
<dd>(default is None, includes all shapes)
specify the shapes of the images to include</dd>
<dt><strong><code>row_max</code></strong> :&ensp;<code>int</code></dt>
<dd>(default is None, includes all rows)
Filter flag used to remove images with rows greater than the
specified value</dd>
<dt><strong><code>row_min</code></strong> :&ensp;<code>int</code></dt>
<dd>(default is None, includes all rows)
Filter flag used to remove images with rows less than the
specified value</dd>
<dt><strong><code>col_max</code></strong> :&ensp;<code>int</code></dt>
<dd>(default is None, includes all columns)
Filter flag used to remove images with columns greater than the
specified value</dd>
<dt><strong><code>col_min</code></strong> :&ensp;<code>int</code></dt>
<dd>(default is None, includes all columns)
Filter flag used to remove images with columns less than the
specified value</dd>
<dt><strong><code>frames_max</code></strong> :&ensp;<code>int</code></dt>
<dd>(default is None, includes all frames)
Filter flag used to remove images with frames greater than the
specified value</dd>
<dt><strong><code>frames_min</code></strong> :&ensp;<code>int</code></dt>
<dd>(default is None, includes all frames)
Filter flag used to remove images with frames less than the
specified value</dd>
<dt><strong><code>age_range</code></strong> :&ensp;<code>list[min, max]</code></dt>
<dd>(Default is None, include all ages)
specify the age range in years to filter images by age</dd>
<dt><strong><code>labels</code></strong> :&ensp;<code>list</code></dt>
<dd>(default is None, includes all labels)
specify the labels of the images to include</dd>
<dt><strong><code>studies</code></strong> :&ensp;<code>list</code></dt>
<dd>(default is None, includes all studies)
specify the studies of the images to include</dd>
<dt><strong><code>manufacturers</code></strong> :&ensp;<code>list</code></dt>
<dd>(default is None, includes all manufacturers)
specify the manufacturers of the images to include</dd>
<dt><strong><code>timing</code></strong> :&ensp;<code>bool</code></dt>
<dd>(default is False) If true will time execution of method,
else will not</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def filter_data(
    cls,
    _2d=True,
    _3d=True,
    shapes: list = None,
    row_max: int = None,
    row_min: int = None,
    col_max: int = None,
    col_min: int = None,
    frames_max: int = None,
    frames_min: int = None,
    age_range: list = None,
    labels: list = None,
    studies: list = None,
    manufacturers: list = None,
    timing=False,
):
    &#34;&#34;&#34;Filters the dataset to include only Dicoms that match the specified
    filter flags. Configures internal class data in a way that all the Data
    methods work the same, but only will be on the filtered data.
    To reset the filtered data to the original dataset, use the
    reset_data method.

    Parameters
    ----------
    _2d : int
        (default is True, includes 2D images)
        Filter flag used to remove 2D images
    _3d : str
        (default is True, includes 3D images)
        Filter flag used to remove 3D images
    shapes: list[&#39;(X1,Y1)&#39;, &#39;(X2,Y2)&#39;, ..., (Xn,Yn,Zn)&#39;]
        (default is None, includes all shapes)
        specify the shapes of the images to include
    row_max: int
        (default is None, includes all rows)
        Filter flag used to remove images with rows greater than the
        specified value
    row_min: int
        (default is None, includes all rows)
        Filter flag used to remove images with rows less than the
        specified value
    col_max: int
        (default is None, includes all columns)
        Filter flag used to remove images with columns greater than the
        specified value
    col_min: int
        (default is None, includes all columns)
        Filter flag used to remove images with columns less than the
        specified value
    frames_max: int
        (default is None, includes all frames)
        Filter flag used to remove images with frames greater than the
        specified value
    frames_min: int
        (default is None, includes all frames)
        Filter flag used to remove images with frames less than the
        specified value
    age_range: list[min, max]
        (Default is None, include all ages)
        specify the age range in years to filter images by age
    labels: list
        (default is None, includes all labels)
        specify the labels of the images to include
    studies: list
        (default is None, includes all studies)
        specify the studies of the images to include
    manufacturers: list
        (default is None, includes all manufacturers)
        specify the manufacturers of the images to include
    timing: bool
        (default is False) If true will time execution of method,
        else will not
    &#34;&#34;&#34;
    t0 = time.time()
    # build the filtered_flags dictionary
    cls._filtered_flags = {
        &#34;2D&#34;: _2d,
        &#34;3D&#34;: _3d,
        &#34;shapes&#34;: shapes,
        &#34;row_max&#34;: row_max,
        &#34;row_min&#34;: row_min,
        &#34;col_max&#34;: col_max,
        &#34;col_min&#34;: col_min,
        &#34;frames_max&#34;: frames_max,
        &#34;frames_min&#34;: frames_min,
        &#34;age_range&#34;: age_range,
        &#34;labels&#34;: labels,
        &#34;studies&#34;: studies,
        &#34;manufacturers&#34;: manufacturers,
    }
    label_to_path_map = {}
    dimension_map = {}
    filtered_map = {}
    temp_labels = {}
    # remove the labels that are not in the filtered_flags first
    if labels is not None:
        for label in labels:
            for i in range(len(cls._labels)):
                if cls._labels[i] == label:
                    temp_labels[i] = cls._labels[i]
                    label_to_path_map[i] = cls._image_paths[i]
    else:
        for i in range(len(cls._labels)):
            temp_labels[i] = cls._labels[i]
            label_to_path_map[i] = cls._image_paths[i]
    # remove the dimensions that are not in the filtered_flags
    if _2d and _3d:
        for k, v in label_to_path_map.items():
            if studies is not None:
                for study in studies:
                    if study in v:
                        dimension_map[k] = v
            else:
                dimension_map[k] = v
    elif _2d:
        for k, v in label_to_path_map.items():
            if (
                os.path.basename(v).startswith(cls.dl.dicom_2d_substring)
                or cls.dl.dicom_2d_substring == &#34;&#34;
            ):
                if studies is not None:
                    for study in studies:
                        if study in v:
                            dimension_map[k] = v
                else:
                    dimension_map[k] = v
    else:
        for k, v in label_to_path_map.items():
            if (
                os.path.basename(v).startswith(cls.dl.dicom_3d_substring)
                or cls.dl.dicom_3d_substring == &#34;&#34;
            ):
                if studies is not None:
                    for study in studies:
                        if study in v:
                            dimension_map[k] = v
                else:
                    dimension_map[k] = v
    # next filter by the shapes of the images
    if shapes is not None:
        pattern = &#34;&#34;
        for shape in shapes:
            print(f&#34;Filtering for shape: {shape}&#34;)
            if shape != shapes[-1]:
                pattern += shape + &#34;|&#34;
            else:
                pattern += shape
        count = 0
        for k, v in dimension_map.items():
            img_path = str(v)
            test_label = cls._labels[int(k)]
            if labels is None or labels.__contains__(test_label):
                ds = dicom.filereader.dcmread(
                    img_path,
                    stop_before_pixels=True,
                    force=True,
                    specific_tags=[&#34;Columns&#34;, &#34;Rows&#34;, &#34;NumberOfFrames&#34;],
                )
                rows = ds.Rows
                cols = ds.Columns
                if os.path.basename(img_path).startswith(cls.dl.dicom_3d_substring):
                    frames = ds.NumberOfFrames
                    shape = str(
                        &#34;(&#34; + str(rows) + &#34;,&#34; + str(cols) + &#34;,&#34; + str(frames) + &#34;)&#34;
                    )
                else:
                    shape = str(&#34;(&#34; + str(rows) + &#34;,&#34; + str(cols) + &#34;)&#34;)
                if re.search(pattern, shape) is not None:
                    filtered_map[k] = v
                if timing:
                    count += 1
                    if count % 100 == 0:
                        percentage_done = int(count / len(dimension_map) * 100)
                        print(f&#34;{percentage_done}% done&#34;)

    elif (
        shapes is None
        and (col_max is not None and row_max is not None)
        or (col_min is not None and row_min is not None)
    ):
        count = 0
        for k, v in dimension_map.items():
            img_path = str(v)
            test_label = cls._labels[int(k)]
            if labels is None or labels.__contains__(test_label):
                ds = dicom.filereader.dcmread(
                    img_path,
                    stop_before_pixels=True,
                    force=True,
                    specific_tags=[&#34;Columns&#34;, &#34;Rows&#34;, &#34;NumberOfFrames&#34;],
                )
                rows = ds.Rows
                cols = ds.Columns
                frames = 1
                if os.path.basename(img_path).startswith(cls.dl.dicom_3d_substring):
                    frames = ds.NumberOfFrames
                if (
                    (col_min is None or col_min &lt;= cols)
                    and (col_max is None or cols &lt;= col_max)
                    and (row_min is None or row_min &lt;= rows)
                    and (row_max is None or rows &lt;= row_max)
                    and (frames_min is None or frames_min &lt;= frames)
                    and (frames_max is None or frames &lt;= frames_max)
                ):
                    filtered_map[k] = v
                if timing:
                    count += 1
                    percentage_done = count / len(dimension_map) * 100
                    if count % 1000 == 0:
                        print(f&#34;{percentage_done}% done&#34;)
    else:
        filtered_map = dimension_map

    # filter by the age range
    temp_map = {}
    count = 0
    if age_range is not None:
        # turning years into months to match how age is stored in dicom
        age_range[0] = int(age_range[0] * 12)
        age_range[1] = int(age_range[1] * 12)
        for k, v in filtered_map.items():
            img_path = str(v)
            test_label = cls._labels[int(k)]
            if labels is None or labels.__contains__(test_label):
                ds = dicom.filereader.dcmread(
                    img_path,
                    stop_before_pixels=True,
                    force=True,
                    specific_tags=[&#34;PatientAge&#34;, &#34;PatientSex&#34;],
                )
                if ds.PatientAge is not None and ds.PatientAge != &#34;&#34;:
                    age = int(ds.PatientAge[:-1])
                    if age_range[0] &lt;= age &lt;= age_range[1]:
                        temp_map[k] = v
                if timing:
                    count += 1
                    percentage_done = count / len(filtered_map) * 100
                    if count % 1000 == 0:
                        print(f&#34;{percentage_done}% done&#34;)
        filtered_map = temp_map

    # filter by manufacturer
    temp_map = {}
    count = 0
    if manufacturers is not None:
        for k, v in filtered_map.items():
            img_path = str(v)
            test_label = cls._labels[int(k)]
            if labels is None or labels.__contains__(test_label):
                ds = dicom.filereader.dcmread(
                    img_path,
                    stop_before_pixels=True,
                    force=True,
                    specific_tags=[&#34;Manufacturer&#34;],
                )
                if ds.Manufacturer is not None and ds.Manufacturer != &#34;&#34;:
                    if manufacturers.__contains__(ds.Manufacturer):
                        temp_map[k] = v
                if timing:
                    count += 1
                    percentage_done = count / len(filtered_map) * 100
                    if count % 1000 == 0:
                        print(f&#34;{percentage_done}% done&#34;)
        filtered_map = temp_map

    cls._image_paths = []
    cls._labels = {}
    cls._study_paths = []
    study_path_map = {}
    image_id = 0
    count = 0
    for k, v in filtered_map.items():
        img_path = str(v)
        cls._image_paths.append(img_path)
        cls._labels[image_id] = temp_labels[int(k)]
        image_id += 1
        study_path = os.path.dirname(img_path)
        if study_path_map.__contains__(study_path):
            continue
        else:
            study_path_map[study_path] = image_id
            cls._study_paths.append(study_path)
        if timing:
            count += 1
            percentage_complete = count / len(filtered_map) * 100
            if count % 1000 == 0:
                print(
                    &#34;Now Processing filtered images: &#34;
                    + str(percentage_complete)
                    + &#34;%&#34;
                )
    cls._init_stats()
    if timing:
        cls.timing(t0, &#34;filter_images&#34;)</code></pre>
</details>
</dd>
<dt id="omama.data.Data.get_image"><code class="name flex">
<span>def <span class="ident">get_image</span></span>(<span>image_id=None, dicom_name=None, path=None, pixels=True, dicom_header=False, timing=False) >types.SimpleNamespace</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the image with the given image id or dicom name or path</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>image_id</code></strong> :&ensp;<code>int</code></dt>
<dd>(default is None, this or the Dicom_ID or path need to be set)
Uses the image_id to fetch Dicom and returns the specified data</dd>
<dt><strong><code>dicom_name</code></strong> :&ensp;<code>str</code></dt>
<dd>(default is None, this or the image_id or path need to be set)
Uses the dicom_name to fetch Dicom, and returns the specified
data</dd>
<dt><strong><code>path</code></strong> :&ensp;<code>str</code></dt>
<dd>(default is None, this or the image_id or dicom_name need to be set)
Uses the path to fetch Dicom, and returns the specified data</dd>
<dt><strong><code>pixels</code></strong> :&ensp;<code>bool</code></dt>
<dd>(default is True) If True will return the pixel array of Dicom,
else will return None</dd>
<dt><strong><code>dicom_header</code></strong> :&ensp;<code>bool</code></dt>
<dd>(default is False) If True will return the dicom header as a
dictionary, else will return None</dd>
<dt><strong><code>timing</code></strong> :&ensp;<code>bool</code></dt>
<dd>(default is False)
If true will time execution of method, else will not</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>image</code></strong> :&ensp;<code>SimpleNamespace</code></dt>
<dd LABELS.Cancer_="LABELS.Cancer," _filepath_:...="'filepath':..." _label_:="'label':" _shape_...="'shape'...">[np.array just the pixels or None if pixels=False, info]
info is dictionary:</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def get_image(
    cls,
    image_id=None,
    dicom_name=None,
    path=None,
    pixels=True,
    dicom_header=False,
    timing=False,
) -&gt; SimpleNamespace:
    &#34;&#34;&#34;Returns the image with the given image id or dicom name or path

    Parameters
    ----------
    image_id : int
        (default is None, this or the Dicom_ID or path need to be set)
        Uses the image_id to fetch Dicom and returns the specified data
    dicom_name : str
        (default is None, this or the image_id or path need to be set)
        Uses the dicom_name to fetch Dicom, and returns the specified  data
    path : str
        (default is None, this or the image_id or dicom_name need to be set)
        Uses the path to fetch Dicom, and returns the specified data
    pixels : bool
        (default is True) If True will return the pixel array of Dicom,
        else will return None
    dicom_header : bool
        (default is False) If True will return the dicom header as a
        dictionary, else will return None
    timing : bool
        (default is False)
        If true will time execution of method, else will not

    Returns
    ------
    image : SimpleNamespace
        [np.array just the pixels or None if pixels=False, info]
        info is dictionary:
        {&#39;label&#39;: LABELS.Cancer, &#39;filepath&#39;:... &#39;shape&#39;...}
    &#34;&#34;&#34;
    t0 = time.time()
    ds = cls._dicom(
        dicom_name=dicom_name,
        image_id=image_id,
        dicom_path=path,
        pixels=pixels,
        dicom_header=dicom_header,
        timing=timing,
    )
    img = None
    study_instance_uid = None
    img_path = cls.path(image_id=image_id, dicom_name=dicom_name, path=path)
    if os.path.basename(img_path).startswith(cls.dl.dicom_3d_substring):
        ds1 = dicom.filereader.dcmread(
            img_path,
            stop_before_pixels=True,
            specific_tags=[
                &#34;PatientID&#34;,
                &#34;InstanceNumber&#34;,
                &#34;SharedFunctionalGroupsSequence&#34;,
                &#34;StudyInstanceUID&#34;,
            ],
        )
        study_instance_uid = ds1.StudyInstanceUID
        image_laterality = (
            ds1.SharedFunctionalGroupsSequence[0]
            .FrameAnatomySequence[0]
            .FrameLaterality
        )
        image_shape = (int(ds.NumberOfFrames), int(ds.Rows), int(ds.Columns))
    else:
        ds1 = dicom.filereader.dcmread(
            img_path,
            stop_before_pixels=True,
            specific_tags=[
                &#34;PatientID&#34;,
                &#34;InstanceNumber&#34;,
                &#34;ImageLaterality&#34;,
                &#34;StudyInstanceUID&#34;,
            ],
        )
        study_instance_uid = ds1.StudyInstanceUID
        image_laterality = ds1.get(&#34;ImageLaterality&#34;)
        image_shape = (int(ds.Rows), int(ds.Columns))

    # img_index = cls._image_id(os.path.basename(img_path))
    # label = cls._labels[int(img_index)]

    # get the dicom name
    sop_uid = os.path.basename(img_path)
    if cls.dl.dicom_3d_substring != &#34;&#34; and cls.dl.dicom_2d_substring != &#34;&#34;:
        # remove the dicom_3d_substring or dicom_2d_substring from the beginning
        sop_uid = sop_uid.replace(cls.dl.dicom_3d_substring + &#34;.&#34;, &#34;&#34;)
        sop_uid = sop_uid.replace(cls.dl.dicom_2d_substring + &#34;.&#34;, &#34;&#34;)

    # get the image label
    label = cls.get_label(sop_uid)

    if pixels is True:
        img = ds.pixel_array
    if dicom_header is False:
        ds = None
    dictionary = {
        &#34;filePath&#34;: img_path,
        &#34;SOPInstanceUID&#34;: sop_uid,
        &#34;StudyInstanceUID&#34;: study_instance_uid,
        &#34;PatientID&#34;: ds1.PatientID,
        &#34;InstanceNumber&#34;: ds1.InstanceNumber,
        &#34;label&#34;: label,
        &#34;imageLaterality&#34;: image_laterality,
        &#34;shape&#34;: image_shape,
        &#34;metadata&#34;: ds,
        &#34;pixels&#34;: img,
    }
    dot_dictionary = SimpleNamespace(**dictionary)
    if timing:
        cls.timing(t0, &#34;get_image&#34;)
    return dot_dictionary</code></pre>
</details>
</dd>
<dt id="omama.data.Data.get_label"><code class="name flex">
<span>def <span class="ident">get_label</span></span>(<span>cancer_id, timing=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the label of the image with the given sop uid</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>cancer_id</code></strong> :&ensp;<code>str</code></dt>
<dd>the sop uid of the image</dd>
<dt><strong><code>timing</code></strong> :&ensp;<code>bool</code></dt>
<dd>(default is False) if True, the time it takes to load the dicom
is printed</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>label</code></strong> :&ensp;<code>str</code></dt>
<dd>the label of the image</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def get_label(cls, cancer_id, timing=False):
    &#34;&#34;&#34;Returns the label of the image with the given sop uid

    Parameters
    ----------
    cancer_id : str
        the sop uid of the image
    timing : bool
        (default is False) if True, the time it takes to load the dicom
        is printed

    Returns
    -------
    label : str
        the label of the image
    &#34;&#34;&#34;
    t0 = time.time()
    if cancer_id in cls.pat_id_to_label_dict:
        label = cls.pat_id_to_label_dict[cancer_id]
    else:
        label = &#34;No Label Information&#34;
    if timing is True:
        cls.timing(t0, &#34;get_label&#34;)
    return label</code></pre>
</details>
</dd>
<dt id="omama.data.Data.get_study"><code class="name flex">
<span>def <span class="ident">get_study</span></span>(<span>study_instance_uid:str=None, study_key:int=None, verbose=False, timing=False) >types.SimpleNamespace</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the study with the given study instance uid or study key</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>study_instance_uid</code></strong> :&ensp;<code>str</code></dt>
<dd>(default is None, this or the ID need to be set)
Uses the StudyInstanceUID to locate the study information and returns
data as dictionary</dd>
<dt><strong><code>study_key</code></strong> :&ensp;<code>int</code></dt>
<dd>(default is None, this or the study_instance_uid needs to be set)
Uses the location of a study which is based off of its index in the
sorted list of all studies</dd>
<dt><strong><code>verbose</code></strong> :&ensp;<code>bool</code></dt>
<dd>(default is False) If True, will include additional information
about the study such as the number of 2D and 3D dicoms in study</dd>
<dt><strong><code>timing</code></strong> :&ensp;<code>bool</code></dt>
<dd>(default is False) Sets timing flag, if true will time execution time
of method, else will not</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>study</code></strong> :&ensp;<code>SimpleNamespace</code></dt>
<dd>{'directory': XX, 'images': [imagefile1, imagefile2, &hellip;]}
iff (verbose==True) =&gt; info': {'3D_count': XX, '2D_count': XX ..and others}</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def get_study(
    cls,
    study_instance_uid: str = None,
    study_key: int = None,
    verbose=False,
    timing=False,
) -&gt; SimpleNamespace:
    &#34;&#34;&#34;Returns the study with the given study instance uid or study key

    Parameters
    ----------
    study_instance_uid : str
        (default is None, this or the ID need to be set)
        Uses the StudyInstanceUID to locate the study information and returns
        data as dictionary
    study_key : int
        (default is None, this or the study_instance_uid needs to be set)
        Uses the location of a study which is based off of its index in the
        sorted list of all studies
    verbose : bool
        (default is False) If True, will include additional information
        about the study such as the number of 2D and 3D dicoms in study
    timing : bool
        (default is False) Sets timing flag, if true will time execution time
         of method, else will not

    Returns
    ------
    study : SimpleNamespace
        {&#39;directory&#39;: XX, &#39;images&#39;: [imagefile1, imagefile2, ...]}
        iff (verbose==True) =&gt; info&#39;: {&#39;3D_count&#39;: XX, &#39;2D_count&#39;: XX ..and others}
    &#34;&#34;&#34;
    _2d = True
    _3d = True
    lab = []
    t0 = time.time()
    if study_instance_uid is not None:
        uid_path = cls.path(study_instance_uid=study_instance_uid, timing=timing)
        file_id = cls._study_key(uid_path, timing=timing)
    elif study_key is not None:
        uid_path = cls.path(study_key=study_key, timing=timing)
        study_instance_uid = os.path.basename(uid_path)
        file_id = study_key
    else:
        raise ValueError(&#34;Either study_instance_uid or study_key must be set&#34;)
    if cls._filtered_flags != {}:  # if there are filters
        _2d = cls._filtered_flags[&#34;2D&#34;]
        _3d = cls._filtered_flags[&#34;3D&#34;]
        lab = cls._filtered_flags[&#34;labels&#34;]
        man = cls._filtered_flags[&#34;manufacturers&#34;]
    image_files = cls._files_in_series(
        path=uid_path, _2d=_2d, _3d=_3d, labels=lab, timing=timing
    )
    if cls.dl.dicom_3d_substring != &#34;&#34;:
        files_3d = [i for i in image_files if cls.dl.dicom_3d_substring in i]
    else:
        # if there is no 3d substring, then all files are 3d
        files_3d = [image_files for i in image_files]
    if cls.dl.dicom_2d_substring != &#34;&#34;:
        files_2d = [i for i in image_files if cls.dl.dicom_2d_substring in i]
    else:
        # if there is no 2d substring, then all files are 2d
        files_2d = [image_files for i in image_files]
    # get a list of image ids from each of the files
    image_ids = [cls._image_id(i) for i in image_files]
    # remove all image_ids tha are -1
    image_ids = [i for i in image_ids if i != -1]
    # use the images ids to get the image labels
    image_labels = [cls._labels[i] for i in image_ids]
    # count each of the types in the image labels
    label_counts = Counter(image_labels)

    if verbose:
        info = {
            &#34;total&#34;: len(files_3d) + len(files_2d),
            &#34;3D count&#34;: len(files_3d),
            &#34;2D count&#34;: len(files_2d),
            &#34;label counts&#34;: label_counts,
        }
    else:
        info = None

    study = {
        &#34;directory&#34;: uid_path,
        &#34;study_uid&#34;: study_instance_uid,
        &#34;study_key&#34;: file_id,
        &#34;images&#34;: image_files,
        &#34;info&#34;: info,
    }
    dot_dictionary = SimpleNamespace(**study)
    if timing is True:
        cls.timing(t0, &#34;get_study&#34;)
    return dot_dictionary</code></pre>
</details>
</dd>
<dt id="omama.data.Data.next_image"><code class="name flex">
<span>def <span class="ident">next_image</span></span>(<span>label=None, randomize=False, timing=False) >Generator[types.SimpleNamespace,None,None]</span>
</code></dt>
<dd>
<div class="desc"><p>Generator to filter and return iteratively all the filtered images in
the dataset</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>_2d</code></strong> :&ensp;<code>bool</code></dt>
<dd>&nbsp;</dd>
<dt>(default is False, this or _3D or both needs to be set to True)</dt>
<dt>Filter flag used to add 2D images to returned set of Dicoms</dt>
<dt><strong><code>_3d</code></strong> :&ensp;<code>bool</code></dt>
<dd>&nbsp;</dd>
<dt>(default is False, this or _2D or both needs to be set to True)</dt>
<dt>Filter flag used to add 3D images to returned set of Dicoms</dt>
<dt><strong><code>label</code></strong> :&ensp;<code>str</code></dt>
<dd>&nbsp;</dd>
<dt>(default is None which is all labeled images)</dt>
<dt>options are IndexCancer, NonCancer, PreIndexCancer</dt>
<dt><strong><code>randomize</code></strong> :&ensp;<code>bool</code></dt>
<dd>&nbsp;</dd>
<dt>(default is False) If True will randomize the order of the</dt>
<dt>returned images</dt>
<dt><strong><code>timing</code></strong> :&ensp;<code>bool</code></dt>
<dd>&nbsp;</dd>
</dl>
<p>(default is False) If true will time execution of method,
else will not</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>image</code></strong> :&ensp;<code>generator</code></dt>
<dd>&nbsp;</dd>
</dl>
<p>[np.array just the pixels, info]
info is dictionary: {'label': LABELS.Cancer, 'filepath':&hellip; 'shape'&hellip;}</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def next_image(
    cls, _2d=False, _3d=False, label=None, randomize=False, timing=False
) -&gt; Generator[SimpleNamespace, None, None]:
    &#34;&#34;&#34;Generator to filter and return iteratively all the filtered images in
    the dataset

    Parameters
    ----------
    _2d : bool
       (default is False, this or _3D or both needs to be set to True)
       Filter flag used to add 2D images to returned set of Dicoms
    _3d : bool
       (default is False, this or _2D or both needs to be set to True)
       Filter flag used to add 3D images to returned set of Dicoms
    label : str
       (default is None which is all labeled images)
       options are IndexCancer, NonCancer, PreIndexCancer
    randomize : bool
       (default is False) If True will randomize the order of the
       returned images
    timing : bool
       (default is False) If true will time execution of method,
       else will not

    Returns
    -------
    image : generator
       [np.array just the pixels, info]
       info is dictionary: {&#39;label&#39;: LABELS.Cancer, &#39;filepath&#39;:... &#39;shape&#39;...}

    &#34;&#34;&#34;
    t0 = time.time()
    generator_map = {}
    image_index_list = {}
    if label is not None:
        for i in range(len(cls._labels)):
            if cls._labels[i] == label:
                image_index_list[i] = cls._image_paths[i]
    else:
        for i in range(len(cls._labels)):
            image_index_list[i] = cls._image_paths[i]

    if _2d and _3d:
        for k, v in image_index_list.items():
            generator_map[k] = v
    elif _2d:
        for k, v in image_index_list.items():
            if os.path.basename(v).startswith(cls.dl.dicom_2d_substring):
                generator_map[k] = v
            elif cls.dl.dicom_2d_substring == &#34;&#34;:
                generator_map[k] = v
    else:
        for k, v in image_index_list.items():
            if os.path.basename(v).startswith(cls.dl.dicom_3d_substring):
                generator_map[k] = v

    # shuffle the generator
    dicoms = list(generator_map.items())
    if randomize is True:
        random.shuffle(dicoms)

    for k, v in dicoms:
        img_path = str(v)
        test_label = cls._labels[int(k)]
        if test_label == label or label is None:
            ds = cls.get_image(path=img_path)
            try:
                yield ds
            except StopIteration:
                break
        else:
            continue
    if timing:
        cls.timing(t0, &#34;next_image_all&#34;)</code></pre>
</details>
</dd>
<dt id="omama.data.Data.partition_data"><code class="name flex">
<span>def <span class="ident">partition_data</span></span>(<span>num_partitions, randomized=True, save_paths_to_files=True, save_directory=None, file_name_prefix=None, timing=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Partitions the data into the specified number of partitions.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>num_partitions</code></strong> :&ensp;<code>int</code></dt>
<dd>The number of partitions to split the data into.</dd>
<dt><strong><code>randomized</code></strong> :&ensp;<code>bool</code></dt>
<dd>If True, the data will be randomized before partitioning.</dd>
<dt><strong><code>save_paths_to_files</code></strong> :&ensp;<code>bool</code></dt>
<dd>If True, the paths to the images will be saved to a file for each
partition.</dd>
<dt><strong><code>save_directory</code></strong> :&ensp;<code>str</code></dt>
<dd>The directory to save the files to. If None, the files will be
saved to the current directory.</dd>
<dt><strong><code>file_name_prefix</code></strong> :&ensp;<code>str</code></dt>
<dd>The prefix to use for the file names. If None, the prefix will be
'partition_'.</dd>
<dt><strong><code>timing</code></strong> :&ensp;<code>bool</code></dt>
<dd>If True, timing information will be printed.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>A list of lists of image paths for each partition.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def partition_data(
    cls,
    num_partitions,
    randomized=True,
    save_paths_to_files=True,
    save_directory=None,
    file_name_prefix=None,
    timing=False,
):
    &#34;&#34;&#34;Partitions the data into the specified number of partitions.

    Parameters
    ----------
    num_partitions : int
        The number of partitions to split the data into.
    randomized : bool
        If True, the data will be randomized before partitioning.
    save_paths_to_files : bool
        If True, the paths to the images will be saved to a file for each
        partition.
    save_directory : str
        The directory to save the files to. If None, the files will be
        saved to the current directory.
    file_name_prefix : str
        The prefix to use for the file names. If None, the prefix will be
        &#39;partition_&#39;.
    timing : bool
        If True, timing information will be printed.

    Returns
    -------
    A list of lists of image paths for each partition.
    &#34;&#34;&#34;
    t0 = time.time()
    image_paths = cls._image_paths.copy()
    if randomized:
        random.shuffle(image_paths)

    if file_name_prefix is None:
        file_name_prefix = &#34;partition_&#34;
    num_images = len(image_paths)
    num_images_per_partition = int(num_images / num_partitions)
    partitioned_paths = []
    for i in range(num_partitions):
        partitioned_paths.append([])
    for i in range(num_images):
        partition_id = int(i / num_images_per_partition)
        partitioned_paths[partition_id].append(image_paths[i])
    if save_paths_to_files:
        if save_directory is None:
            # get the current directory to save the files to
            save_directory = os.path.dirname(os.path.realpath(__file__))
        print(&#34;Saving partitioned paths to files in: &#34; + save_directory)
        for i in range(num_partitions):
            partition_path = os.path.join(
                save_directory, file_name_prefix + str(i) + &#34;.txt&#34;
            )
            with open(partition_path, &#34;w&#34;) as f:
                for path in partitioned_paths[i]:
                    f.write(path + &#34;\n&#34;)
    if timing:
        cls.timing(t0, &#34;partition_data&#34;)
    return partitioned_paths</code></pre>
</details>
</dd>
<dt id="omama.data.Data.path"><code class="name flex">
<span>def <span class="ident">path</span></span>(<span>image_id:int=None, dicom_name:str=None, path:str=None, study_instance_uid:str=None, study_key:int=None, timing=False) >str</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the path to the image, given one of the several ids</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>image_id</code></strong> :&ensp;<code>int</code></dt>
<dd>(default is None) the id of the image</dd>
<dt><strong><code>dicom_name</code></strong> :&ensp;<code>str</code></dt>
<dd>(default is None) the name of the dicom file</dd>
<dt><strong><code>path</code></strong> :&ensp;<code>str</code></dt>
<dd>(default is None) the path of the image</dd>
<dt><strong><code>study_instance_uid</code></strong> :&ensp;<code>str</code></dt>
<dd>(default is None) the study instance uid of the image</dd>
<dt><strong><code>study_key</code></strong> :&ensp;<code>int</code></dt>
<dd>(default is None) the key of the study</dd>
<dt><strong><code>timing</code></strong> :&ensp;<code>bool</code></dt>
<dd>(default is False) if True, the time it takes to find the path is printed</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>path</code></strong> :&ensp;<code>str</code></dt>
<dd>the path of the image</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def path(
    cls,
    image_id: int = None,
    dicom_name: str = None,
    path: str = None,
    study_instance_uid: str = None,
    study_key: int = None,
    timing=False,
) -&gt; str:
    &#34;&#34;&#34;Returns the path to the image, given one of the several ids

    Parameters
    ----------
    image_id : int
        (default is None) the id of the image
    dicom_name : str
        (default is None) the name of the dicom file
    path : str
        (default is None) the path of the image
    study_instance_uid : str
        (default is None) the study instance uid of the image
    study_key : int
        (default is None) the key of the study
    timing : bool
        (default is False) if True, the time it takes to find the path is printed

    Returns
    -------
    path : str
        the path of the image
    &#34;&#34;&#34;
    t0 = time.time()
    if image_id is not None:
        path = cls._image_paths[image_id]
    elif dicom_name is not None:
        path = &#34;&#34;.join([s for s in cls._image_paths if dicom_name in s])
    elif path is not None:
        path = path
    elif study_instance_uid is not None:
        file_id = [
            idx for idx, s in enumerate(cls._study_paths) if study_instance_uid in s
        ][0]
        path = cls._study_paths[file_id]
    elif study_key is not None:
        path = cls._study_paths[study_key]
    else:
        return (
            &#34;Error: No valid image_id, dicom_name, path, &#34;
            &#34;study_instance_uid or study_key was specified &#34;
        )
    if timing is True:
        cls.timing(t0, &#34;get_path&#34;)
    return path</code></pre>
</details>
</dd>
<dt id="omama.data.Data.random_sample"><code class="name flex">
<span>def <span class="ident">random_sample</span></span>(<span>size, timing=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Randomly samples the data.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>size</code></strong> :&ensp;<code>int</code></dt>
<dd>The number of images to sample.</dd>
<dt><strong><code>timing</code></strong> :&ensp;<code>bool</code></dt>
<dd>If True, timing information will be printed.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>A list of image paths.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def random_sample(cls, size, timing=False):
    &#34;&#34;&#34;Randomly samples the data.

    Parameters
    ----------
    size : int
        The number of images to sample.
    timing : bool
        If True, timing information will be printed.

    Returns
    -------
    A list of image paths.
    &#34;&#34;&#34;
    t0 = time.time()
    image_paths = cls._image_paths.copy()
    random.shuffle(image_paths)
    if timing:
        cls.timing(t0, &#34;random_sample&#34;)
    return image_paths[:size]</code></pre>
</details>
</dd>
<dt id="omama.data.Data.reset_data"><code class="name flex">
<span>def <span class="ident">reset_data</span></span>(<span>timing=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Resets the data to the original data</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def reset_data(cls, timing=False):
    &#34;&#34;&#34;Resets the data to the original data&#34;&#34;&#34;
    t0 = time.time()
    cls._filtered_flags = {}
    cls._image_paths = []
    cls._labels = {}
    cls._study_paths = []
    cls._init()
    if timing:
        cls.timing(t0, &#34;reset_data&#34;)</code></pre>
</details>
</dd>
<dt id="omama.data.Data.set_dicom_tags"><code class="name flex">
<span>def <span class="ident">set_dicom_tags</span></span>(<span>tags)</span>
</code></dt>
<dd>
<div class="desc"><p>Sets the tags to be used when reading dicom files with python
iterators and generators.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>tags</code></strong> :&ensp;<code>list</code> of <code>str</code></dt>
<dd>The tags to be used when reading dicom files with python iterators
and generators.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def set_dicom_tags(cls, tags):
    &#34;&#34;&#34;Sets the tags to be used when reading dicom files with python
    iterators and generators.

    Parameters
    ----------
    tags : list of str
        The tags to be used when reading dicom files with python iterators
        and generators.
    &#34;&#34;&#34;
    cls.dl.dicom_tags = tags</code></pre>
</details>
</dd>
<dt id="omama.data.Data.timing"><code class="name flex">
<span>def <span class="ident">timing</span></span>(<span>t0, label:str)</span>
</code></dt>
<dd>
<div class="desc"><p>Prints the time it takes to perform a certain action</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>t0</code></strong> :&ensp;<code>float</code></dt>
<dd>the time when the action was performed</dd>
<dt><strong><code>label</code></strong> :&ensp;<code>str</code></dt>
<dd>the label of the action</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def timing(t0, label: str):
    &#34;&#34;&#34;Prints the time it takes to perform a certain action

    Parameters
    ----------
    t0 : float
        the time when the action was performed
    label : str
        the label of the action
    &#34;&#34;&#34;
    print(
        &#34;{:&lt;25s}{:&lt;10s}{:&gt;10f}{:^5s}&#34;.format(
            label, &#34;...took &#34;, time.time() - t0, &#34; seconds&#34;
        )
    )</code></pre>
</details>
</dd>
<dt id="omama.data.Data.to_text_file"><code class="name flex">
<span>def <span class="ident">to_text_file</span></span>(<span>file_path=None, file_name=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Writes each path from the image_paths list to a text file each
separated by a new line</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>file_name</code></strong> :&ensp;<code>str</code></dt>
<dd>the name of the file to write to</dd>
<dt><strong><code>file_path</code></strong> :&ensp;<code>str</code></dt>
<dd>the path to the file to write to</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>file_path</code></strong> :&ensp;<code>str</code></dt>
<dd>the path to the file that was written to</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def to_text_file(cls, file_path=None, file_name=None):
    &#34;&#34;&#34;Writes each path from the image_paths list to a text file each
    separated by a new line

    Parameters
    ----------
    file_name : str
        the name of the file to write to
    file_path : str
        the path to the file to write to

    Returns
    -------
    file_path : str
        the path to the file that was written to
    &#34;&#34;&#34;
    if file_path is None:
        # get current working directory
        file_path = os.getcwd() + &#34;/&#34;
    if file_name is None:
        file_name = &#34;image_paths.txt&#34;
    with open(file_path + file_name, &#34;w&#34;) as f:
        for path in cls._image_paths:
            # check if it is the last line in the file and if it is, don&#39;t
            # add a new line
            if path != cls._image_paths[-1]:
                f.write(path + &#34;\n&#34;)
            else:
                f.write(path)
    return file_path + file_name</code></pre>
</details>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="omama.data.Data.image_paths"><code class="name">var <span class="ident">image_paths</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def image_paths(self):
    return self._image_paths</code></pre>
</details>
</dd>
<dt id="omama.data.Data.labels"><code class="name">var <span class="ident">labels</span></code></dt>
<dd>
<div class="desc"><p>Returns the labels of the Data object instance</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def labels(cls):
    &#34;&#34;&#34;Returns the labels of the Data object instance&#34;&#34;&#34;
    return cls._labels</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="omama" href="index.html">omama</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="omama.data.Data" href="#omama.data.Data">Data</a></code></h4>
<ul class="">
<li><code><a title="omama.data.Data.destroy" href="#omama.data.Data.destroy">destroy</a></code></li>
<li><code><a title="omama.data.Data.dl" href="#omama.data.Data.dl">dl</a></code></li>
<li><code><a title="omama.data.Data.filter_data" href="#omama.data.Data.filter_data">filter_data</a></code></li>
<li><code><a title="omama.data.Data.get_image" href="#omama.data.Data.get_image">get_image</a></code></li>
<li><code><a title="omama.data.Data.get_label" href="#omama.data.Data.get_label">get_label</a></code></li>
<li><code><a title="omama.data.Data.get_study" href="#omama.data.Data.get_study">get_study</a></code></li>
<li><code><a title="omama.data.Data.image_paths" href="#omama.data.Data.image_paths">image_paths</a></code></li>
<li><code><a title="omama.data.Data.instance" href="#omama.data.Data.instance">instance</a></code></li>
<li><code><a title="omama.data.Data.labels" href="#omama.data.Data.labels">labels</a></code></li>
<li><code><a title="omama.data.Data.next_image" href="#omama.data.Data.next_image">next_image</a></code></li>
<li><code><a title="omama.data.Data.partition_data" href="#omama.data.Data.partition_data">partition_data</a></code></li>
<li><code><a title="omama.data.Data.pat_id_to_label_dict" href="#omama.data.Data.pat_id_to_label_dict">pat_id_to_label_dict</a></code></li>
<li><code><a title="omama.data.Data.path" href="#omama.data.Data.path">path</a></code></li>
<li><code><a title="omama.data.Data.random_sample" href="#omama.data.Data.random_sample">random_sample</a></code></li>
<li><code><a title="omama.data.Data.reset_data" href="#omama.data.Data.reset_data">reset_data</a></code></li>
<li><code><a title="omama.data.Data.set_dicom_tags" href="#omama.data.Data.set_dicom_tags">set_dicom_tags</a></code></li>
<li><code><a title="omama.data.Data.timing" href="#omama.data.Data.timing">timing</a></code></li>
<li><code><a title="omama.data.Data.to_text_file" href="#omama.data.Data.to_text_file">to_text_file</a></code></li>
<li><code><a title="omama.data.Data.total_2d_cancer" href="#omama.data.Data.total_2d_cancer">total_2d_cancer</a></code></li>
<li><code><a title="omama.data.Data.total_2d_noncancer" href="#omama.data.Data.total_2d_noncancer">total_2d_noncancer</a></code></li>
<li><code><a title="omama.data.Data.total_2d_preindex" href="#omama.data.Data.total_2d_preindex">total_2d_preindex</a></code></li>
<li><code><a title="omama.data.Data.total_3d_cancer" href="#omama.data.Data.total_3d_cancer">total_3d_cancer</a></code></li>
<li><code><a title="omama.data.Data.total_3d_noncancer" href="#omama.data.Data.total_3d_noncancer">total_3d_noncancer</a></code></li>
<li><code><a title="omama.data.Data.total_3d_preindex" href="#omama.data.Data.total_3d_preindex">total_3d_preindex</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>